   1               		.file	"uart.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	__vector_18
  12               	__vector_18:
  13               	.LFB1:
  14               		.file 1 "uart.c"
   1:uart.c        **** /*************************************************************************
   2:uart.c        **** Title:    Interrupt UART library with receive/transmit circular buffers
   3:uart.c        **** Author:   Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   4:uart.c        **** File:     $Id: uart.c,v 1.6.2.1 2007/07/01 11:14:38 peter Exp $
   5:uart.c        **** Software: AVR-GCC 4.1, AVR Libc 1.4.6 or higher
   6:uart.c        **** Hardware: any AVR with built-in UART, 
   7:uart.c        **** License:  GNU General Public License 
   8:uart.c        ****           
   9:uart.c        **** DESCRIPTION:
  10:uart.c        ****     An interrupt is generated when the UART has finished transmitting or
  11:uart.c        ****     receiving a byte. The interrupt handling routines use circular buffers
  12:uart.c        ****     for buffering received and transmitted data.
  13:uart.c        ****     
  14:uart.c        ****     The UART_RX_BUFFER_SIZE and UART_TX_BUFFER_SIZE variables define
  15:uart.c        ****     the buffer size in bytes. Note that these variables must be a 
  16:uart.c        ****     power of 2.
  17:uart.c        ****     
  18:uart.c        **** USAGE:
  19:uart.c        ****     Refere to the header file uart.h for a description of the routines. 
  20:uart.c        ****     See also example test_uart.c.
  21:uart.c        **** 
  22:uart.c        **** NOTES:
  23:uart.c        ****     Based on Atmel Application Note AVR306
  24:uart.c        ****                     
  25:uart.c        **** LICENSE:
  26:uart.c        ****     Copyright (C) 2006 Peter Fleury
  27:uart.c        **** 
  28:uart.c        ****     This program is free software; you can redistribute it and/or modify
  29:uart.c        ****     it under the terms of the GNU General Public License as published by
  30:uart.c        ****     the Free Software Foundation; either version 2 of the License, or
  31:uart.c        ****     any later version.
  32:uart.c        **** 
  33:uart.c        ****     This program is distributed in the hope that it will be useful,
  34:uart.c        ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  35:uart.c        ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  36:uart.c        ****     GNU General Public License for more details.
  37:uart.c        ****                         
  38:uart.c        **** *************************************************************************/
  39:uart.c        **** 
  40:uart.c        **** /************************************************************************
  41:uart.c        **** uart_available, uart_flush, uart1_available, and uart1_flush functions
  42:uart.c        **** were adapted from the Arduino HardwareSerial.h library by Tim Sharpe on 
  43:uart.c        **** 11 Jan 2009.  The license info for HardwareSerial.h is as follows:
  44:uart.c        **** 
  45:uart.c        ****   HardwareSerial.cpp - Hardware serial library for Wiring
  46:uart.c        ****   Copyright (c) 2006 Nicholas Zambetti.  All right reserved.
  47:uart.c        **** 
  48:uart.c        ****   This library is free software; you can redistribute it and/or
  49:uart.c        ****   modify it under the terms of the GNU Lesser General Public
  50:uart.c        ****   License as published by the Free Software Foundation; either
  51:uart.c        ****   version 2.1 of the License, or (at your option) any later version.
  52:uart.c        **** 
  53:uart.c        ****   This library is distributed in the hope that it will be useful,
  54:uart.c        ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  55:uart.c        ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  56:uart.c        ****   Lesser General Public License for more details.
  57:uart.c        **** 
  58:uart.c        ****   You should have received a copy of the GNU Lesser General Public
  59:uart.c        ****   License along with this library; if not, write to the Free Software
  60:uart.c        ****   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  61:uart.c        ****   
  62:uart.c        ****   Modified 23 November 2006 by David A. Mellis
  63:uart.c        **** ************************************************************************/
  64:uart.c        **** 
  65:uart.c        **** /************************************************************************
  66:uart.c        **** Changelog for modifications made by Tim Sharpe, starting with the current
  67:uart.c        ****   library version on his Web site as of 05/01/2009. 
  68:uart.c        **** 
  69:uart.c        **** Date        Description
  70:uart.c        **** =========================================================================
  71:uart.c        **** 05/11/2009  Changed all existing UARTx_RECEIVE_INTERRUPT and UARTx_TRANSMIT_INTERRUPT
  72:uart.c        ****               macros to use the "_vect" format introduced in AVR-Libc
  73:uart.c        **** 			  v1.4.0.  Had to split the 3290 and 6490 out of their existing
  74:uart.c        **** 			  macro due to an inconsistency in the UART0_RECEIVE_INTERRUPT 
  75:uart.c        **** 			  vector name (seems like a typo: USART_RX_vect for the 3290/6490
  76:uart.c        **** 			  vice USART0_RX_vect for the others in the macro).
  77:uart.c        **** 			Verified all existing macro register names against the device
  78:uart.c        **** 			  header files in AVR-Libc v1.6.6 to catch any inconsistencies.
  79:uart.c        **** 05/12/2009  Added support for 48P, 88P, 168P, and 328P by adding them to the
  80:uart.c        ****                existing 48/88/168 macro.
  81:uart.c        **** 			Added Arduino-style available() and flush() functions for both
  82:uart.c        **** 			supported UARTs.  Really wanted to keep them out of the library, so
  83:uart.c        **** 			that it would be as close as possible to Peter Fleury's original
  84:uart.c        **** 			library, but has scoping issues accessing internal variables from
  85:uart.c        **** 			another program.  Go C!
  86:uart.c        **** 05/13/2009  Changed Interrupt Service Routine label from the old "SIGNAL" to
  87:uart.c        ****                the "ISR" format introduced in AVR-Libc v1.4.0.
  88:uart.c        **** 
  89:uart.c        **** ************************************************************************/
  90:uart.c        **** 
  91:uart.c        **** #include <avr/io.h>
  92:uart.c        **** #include <avr/interrupt.h>
  93:uart.c        **** #include <avr/pgmspace.h>
  94:uart.c        **** 
  95:uart.c        **** #include "uart.h"
  96:uart.c        **** 
  97:uart.c        **** /*
  98:uart.c        ****  *  constants and macros
  99:uart.c        ****  */
 100:uart.c        **** 
 101:uart.c        **** /* size of RX/TX buffers */
 102:uart.c        **** #define UART_RX_BUFFER_MASK ( UART_RX_BUFFER_SIZE - 1)
 103:uart.c        **** #define UART_TX_BUFFER_MASK ( UART_TX_BUFFER_SIZE - 1)
 104:uart.c        **** 
 105:uart.c        **** #if ( UART_RX_BUFFER_SIZE & UART_RX_BUFFER_MASK )
 106:uart.c        **** #error RX buffer size is not a power of 2
 107:uart.c        **** #endif
 108:uart.c        **** #if ( UART_TX_BUFFER_SIZE & UART_TX_BUFFER_MASK )
 109:uart.c        **** #error TX buffer size is not a power of 2
 110:uart.c        **** #endif
 111:uart.c        **** 
 112:uart.c        **** #if defined(__AVR_AT90S2313__) \
 113:uart.c        ****  || defined(__AVR_AT90S4414__) || defined(__AVR_AT90S4434__) \
 114:uart.c        ****  || defined(__AVR_AT90S8515__) || defined(__AVR_AT90S8535__) \
 115:uart.c        ****  || defined(__AVR_ATmega103__)
 116:uart.c        ****  /* old AVR classic or ATmega103 with one UART */
 117:uart.c        ****  #define AT90_UART
 118:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect
 119:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
 120:uart.c        ****  #define UART0_STATUS   USR
 121:uart.c        ****  #define UART0_CONTROL  UCR
 122:uart.c        ****  #define UART0_DATA     UDR  
 123:uart.c        ****  #define UART0_UDRIE    UDRIE
 124:uart.c        **** #elif defined(__AVR_AT90S2333__) || defined(__AVR_AT90S4433__)
 125:uart.c        ****  /* old AVR classic with one UART */
 126:uart.c        ****  #define AT90_UART
 127:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect
 128:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
 129:uart.c        ****  #define UART0_STATUS   UCSRA
 130:uart.c        ****  #define UART0_CONTROL  UCSRB
 131:uart.c        ****  #define UART0_DATA     UDR 
 132:uart.c        ****  #define UART0_UDRIE    UDRIE
 133:uart.c        **** #elif  defined(__AVR_ATmega8__)  || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
 134:uart.c        ****   || defined(__AVR_ATmega323__)
 135:uart.c        ****   /* ATmega with one USART */
 136:uart.c        ****  #define ATMEGA_USART
 137:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART_RXC_vect
 138:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 139:uart.c        ****  #define UART0_STATUS   UCSRA
 140:uart.c        ****  #define UART0_CONTROL  UCSRB
 141:uart.c        ****  #define UART0_DATA     UDR
 142:uart.c        ****  #define UART0_UDRIE    UDRIE
 143:uart.c        **** #elif  defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 144:uart.c        ****   /* ATmega with one USART */
 145:uart.c        ****  #define ATMEGA_USART
 146:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 147:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 148:uart.c        ****  #define UART0_STATUS   UCSRA
 149:uart.c        ****  #define UART0_CONTROL  UCSRB
 150:uart.c        ****  #define UART0_DATA     UDR
 151:uart.c        ****  #define UART0_UDRIE    UDRIE
 152:uart.c        **** #elif defined(__AVR_ATmega163__) 
 153:uart.c        ****   /* ATmega163 with one UART */
 154:uart.c        ****  #define ATMEGA_UART
 155:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   UART_RX_vect
 156:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  UART_UDRE_vect
 157:uart.c        ****  #define UART0_STATUS   UCSRA
 158:uart.c        ****  #define UART0_CONTROL  UCSRB
 159:uart.c        ****  #define UART0_DATA     UDR
 160:uart.c        ****  #define UART0_UDRIE    UDRIE
 161:uart.c        **** #elif defined(__AVR_ATmega162__) 
 162:uart.c        ****  /* ATmega with two USART */
 163:uart.c        ****  #define ATMEGA_USART0
 164:uart.c        ****  #define ATMEGA_USART1
 165:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART0_RXC_vect
 166:uart.c        ****  #define UART1_RECEIVE_INTERRUPT   USART1_RXC_vect
 167:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 168:uart.c        ****  #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 169:uart.c        ****  #define UART0_STATUS   UCSR0A
 170:uart.c        ****  #define UART0_CONTROL  UCSR0B
 171:uart.c        ****  #define UART0_DATA     UDR0
 172:uart.c        ****  #define UART0_UDRIE    UDRIE0
 173:uart.c        ****  #define UART1_STATUS   UCSR1A
 174:uart.c        ****  #define UART1_CONTROL  UCSR1B
 175:uart.c        ****  #define UART1_DATA     UDR1
 176:uart.c        ****  #define UART1_UDRIE    UDRIE1
 177:uart.c        **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) 
 178:uart.c        ****  /* ATmega with two USART */
 179:uart.c        ****  #define ATMEGA_USART0
 180:uart.c        ****  #define ATMEGA_USART1
 181:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 182:uart.c        ****  #define UART1_RECEIVE_INTERRUPT   USART1_RX_vect
 183:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 184:uart.c        ****  #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 185:uart.c        ****  #define UART0_STATUS   UCSR0A
 186:uart.c        ****  #define UART0_CONTROL  UCSR0B
 187:uart.c        ****  #define UART0_DATA     UDR0
 188:uart.c        ****  #define UART0_UDRIE    UDRIE0
 189:uart.c        ****  #define UART1_STATUS   UCSR1A
 190:uart.c        ****  #define UART1_CONTROL  UCSR1B
 191:uart.c        ****  #define UART1_DATA     UDR1
 192:uart.c        ****  #define UART1_UDRIE    UDRIE1
 193:uart.c        **** #elif defined(__AVR_ATmega161__)
 194:uart.c        ****  /* ATmega with UART */
 195:uart.c        ****  #error "AVR ATmega161 currently not supported by this libaray !"
 196:uart.c        **** #elif defined(__AVR_ATmega169__) 
 197:uart.c        ****  /* ATmega with one USART */
 198:uart.c        ****  #define ATMEGA_USART
 199:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 200:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 201:uart.c        ****  #define UART0_STATUS   UCSRA
 202:uart.c        ****  #define UART0_CONTROL  UCSRB
 203:uart.c        ****  #define UART0_DATA     UDR
 204:uart.c        ****  #define UART0_UDRIE    UDRIE
 205:uart.c        **** #elif defined(__AVR_ATmega48__) ||defined(__AVR_ATmega88__) || defined(__AVR_ATmega168__) || \
 206:uart.c        ****       defined(__AVR_ATmega48P__) ||defined(__AVR_ATmega88P__) || defined(__AVR_ATmega168P__) || \
 207:uart.c        ****       defined(__AVR_ATmega328P__) 
 208:uart.c        ****  /* TLS-Added 48P/88P/168P/328P */
 209:uart.c        ****  /* ATmega with one USART */
 210:uart.c        ****  #define ATMEGA_USART0
 211:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 212:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 213:uart.c        ****  #define UART0_STATUS   UCSR0A
 214:uart.c        ****  #define UART0_CONTROL  UCSR0B
 215:uart.c        ****  #define UART0_DATA     UDR0
 216:uart.c        ****  #define UART0_UDRIE    UDRIE0
 217:uart.c        **** #elif defined(__AVR_ATtiny2313__)
 218:uart.c        ****  #define ATMEGA_USART
 219:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART_RX_vect 
 220:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART_UDRE_vect
 221:uart.c        ****  #define UART0_STATUS   UCSRA
 222:uart.c        ****  #define UART0_CONTROL  UCSRB
 223:uart.c        ****  #define UART0_DATA     UDR
 224:uart.c        ****  #define UART0_UDRIE    UDRIE
 225:uart.c        **** #elif defined(__AVR_ATmega329__) ||\
 226:uart.c        ****       defined(__AVR_ATmega649__) ||\
 227:uart.c        ****       defined(__AVR_ATmega325__) ||defined(__AVR_ATmega3250__) ||\
 228:uart.c        ****       defined(__AVR_ATmega645__) ||defined(__AVR_ATmega6450__)
 229:uart.c        ****   /* ATmega with one USART */
 230:uart.c        ****   #define ATMEGA_USART0
 231:uart.c        ****   #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 232:uart.c        ****   #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 233:uart.c        ****   #define UART0_STATUS   UCSR0A
 234:uart.c        ****   #define UART0_CONTROL  UCSR0B
 235:uart.c        ****   #define UART0_DATA     UDR0
 236:uart.c        ****   #define UART0_UDRIE    UDRIE0
 237:uart.c        **** #elif defined(__AVR_ATmega3290__) ||\
 238:uart.c        ****       defined(__AVR_ATmega6490__)
 239:uart.c        ****   /* TLS-Separated these two from the previous group because of inconsistency in the USART_RX */
 240:uart.c        ****   /* ATmega with one USART */
 241:uart.c        ****   #define ATMEGA_USART0
 242:uart.c        ****   #define UART0_RECEIVE_INTERRUPT   USART_RX_vect
 243:uart.c        ****   #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 244:uart.c        ****   #define UART0_STATUS   UCSR0A
 245:uart.c        ****   #define UART0_CONTROL  UCSR0B
 246:uart.c        ****   #define UART0_DATA     UDR0
 247:uart.c        ****   #define UART0_UDRIE    UDRIE0
 248:uart.c        **** #elif defined(__AVR_ATmega2560__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega640__)
 249:uart.c        **** /* ATmega with two USART */
 250:uart.c        ****   #define ATMEGA_USART0
 251:uart.c        ****   #define ATMEGA_USART1
 252:uart.c        ****   #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 253:uart.c        ****   #define UART1_RECEIVE_INTERRUPT   USART0_UDRE_vect
 254:uart.c        ****   #define UART0_TRANSMIT_INTERRUPT  USART1_RX_vect
 255:uart.c        ****   #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 256:uart.c        ****   #define UART0_STATUS   UCSR0A
 257:uart.c        ****   #define UART0_CONTROL  UCSR0B
 258:uart.c        ****   #define UART0_DATA     UDR0
 259:uart.c        ****   #define UART0_UDRIE    UDRIE0
 260:uart.c        ****   #define UART1_STATUS   UCSR1A
 261:uart.c        ****   #define UART1_CONTROL  UCSR1B
 262:uart.c        ****   #define UART1_DATA     UDR1
 263:uart.c        ****   #define UART1_UDRIE    UDRIE1  
 264:uart.c        **** #elif defined(__AVR_ATmega644__)
 265:uart.c        ****  /* ATmega with one USART */
 266:uart.c        ****  #define ATMEGA_USART0
 267:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 268:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART0_UDRE_vect
 269:uart.c        ****  #define UART0_STATUS   UCSR0A
 270:uart.c        ****  #define UART0_CONTROL  UCSR0B
 271:uart.c        ****  #define UART0_DATA     UDR0
 272:uart.c        ****  #define UART0_UDRIE    UDRIE0
 273:uart.c        **** #elif defined(__AVR_ATmega164P__) || defined(__AVR_ATmega324P__) || defined(__AVR_ATmega644P__)
 274:uart.c        ****  /* ATmega with two USART */
 275:uart.c        ****  #define ATMEGA_USART0
 276:uart.c        ****  #define ATMEGA_USART1
 277:uart.c        ****  #define UART0_RECEIVE_INTERRUPT   USART0_RX_vect
 278:uart.c        ****  #define UART1_RECEIVE_INTERRUPT   USART0_UDRE_vect
 279:uart.c        ****  #define UART0_TRANSMIT_INTERRUPT  USART1_RX_vect
 280:uart.c        ****  #define UART1_TRANSMIT_INTERRUPT  USART1_UDRE_vect
 281:uart.c        ****  #define UART0_STATUS   UCSR0A
 282:uart.c        ****  #define UART0_CONTROL  UCSR0B
 283:uart.c        ****  #define UART0_DATA     UDR0
 284:uart.c        ****  #define UART0_UDRIE    UDRIE0
 285:uart.c        ****  #define UART1_STATUS   UCSR1A
 286:uart.c        ****  #define UART1_CONTROL  UCSR1B
 287:uart.c        ****  #define UART1_DATA     UDR1
 288:uart.c        ****  #define UART1_UDRIE    UDRIE1
 289:uart.c        **** #else
 290:uart.c        ****  #error "no UART definition for MCU available"
 291:uart.c        **** #endif
 292:uart.c        **** 
 293:uart.c        **** 
 294:uart.c        **** /*
 295:uart.c        ****  *  module global variables
 296:uart.c        ****  */
 297:uart.c        **** static volatile unsigned char UART_TxBuf[UART_TX_BUFFER_SIZE];
 298:uart.c        **** static volatile unsigned char UART_RxBuf[UART_RX_BUFFER_SIZE];
 299:uart.c        **** static volatile unsigned char UART_TxHead;
 300:uart.c        **** static volatile unsigned char UART_TxTail;
 301:uart.c        **** static volatile unsigned char UART_RxHead;
 302:uart.c        **** static volatile unsigned char UART_RxTail;
 303:uart.c        **** static volatile unsigned char UART_LastRxError;
 304:uart.c        **** 
 305:uart.c        **** #if defined( ATMEGA_USART1 )
 306:uart.c        **** static volatile unsigned char UART1_TxBuf[UART_TX_BUFFER_SIZE];
 307:uart.c        **** static volatile unsigned char UART1_RxBuf[UART_RX_BUFFER_SIZE];
 308:uart.c        **** static volatile unsigned char UART1_TxHead;
 309:uart.c        **** static volatile unsigned char UART1_TxTail;
 310:uart.c        **** static volatile unsigned char UART1_RxHead;
 311:uart.c        **** static volatile unsigned char UART1_RxTail;
 312:uart.c        **** static volatile unsigned char UART1_LastRxError;
 313:uart.c        **** #endif
 314:uart.c        **** 
 315:uart.c        **** 
 316:uart.c        **** 
 317:uart.c        **** ISR(UART0_RECEIVE_INTERRUPT)
 318:uart.c        **** /*************************************************************************
 319:uart.c        **** Function: UART Receive Complete interrupt
 320:uart.c        **** Purpose:  called when the UART has received a character
 321:uart.c        **** **************************************************************************/
 322:uart.c        **** {
  15               		.loc 1 322 0
  16               		.cfi_startproc
  17 0000 1F92      		push r1
  18               	.LCFI0:
  19               		.cfi_def_cfa_offset 3
  20               		.cfi_offset 1, -2
  21 0002 0F92      		push r0
  22               	.LCFI1:
  23               		.cfi_def_cfa_offset 4
  24               		.cfi_offset 0, -3
  25 0004 0FB6      		in r0,__SREG__
  26 0006 0F92      		push r0
  27 0008 1124      		clr __zero_reg__
  28 000a 2F93      		push r18
  29               	.LCFI2:
  30               		.cfi_def_cfa_offset 5
  31               		.cfi_offset 18, -4
  32 000c 8F93      		push r24
  33               	.LCFI3:
  34               		.cfi_def_cfa_offset 6
  35               		.cfi_offset 24, -5
  36 000e 9F93      		push r25
  37               	.LCFI4:
  38               		.cfi_def_cfa_offset 7
  39               		.cfi_offset 25, -6
  40 0010 EF93      		push r30
  41               	.LCFI5:
  42               		.cfi_def_cfa_offset 8
  43               		.cfi_offset 30, -7
  44 0012 FF93      		push r31
  45               	.LCFI6:
  46               		.cfi_def_cfa_offset 9
  47               		.cfi_offset 31, -8
  48               	/* prologue: Signal */
  49               	/* frame size = 0 */
  50               	/* stack size = 8 */
  51               	.L__stack_usage = 8
 323:uart.c        ****     unsigned char tmphead;
 324:uart.c        ****     unsigned char data;
 325:uart.c        ****     unsigned char usr;
 326:uart.c        ****     unsigned char lastRxError;
 327:uart.c        ****  
 328:uart.c        ****     /* read UART status register and UART data register */ 
 329:uart.c        ****     usr  = UART0_STATUS;
  52               		.loc 1 329 0
  53 0014 8091 C000 		lds r24,192
  54               	.LVL0:
 330:uart.c        ****     data = UART0_DATA;
  55               		.loc 1 330 0
  56 0018 9091 C600 		lds r25,198
  57               	.LVL1:
 331:uart.c        ****     
 332:uart.c        ****     /* */
 333:uart.c        **** #if defined( AT90_UART )
 334:uart.c        ****     lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
 335:uart.c        **** #elif defined( ATMEGA_USART )
 336:uart.c        ****     lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
 337:uart.c        **** #elif defined( ATMEGA_USART0 )
 338:uart.c        ****     lastRxError = (usr & (_BV(FE0)|_BV(DOR0)) );
  58               		.loc 1 338 0
  59 001c 8871      		andi r24,lo8(24)
  60               	.LVL2:
 339:uart.c        **** #elif defined ( ATMEGA_UART )
 340:uart.c        ****     lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
 341:uart.c        **** #endif
 342:uart.c        ****         
 343:uart.c        ****     /* calculate buffer index */ 
 344:uart.c        ****     tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
  61               		.loc 1 344 0
  62 001e E091 0000 		lds r30,UART_RxHead
  63 0022 EF5F      		subi r30,lo8(-(1))
  64 0024 EF73      		andi r30,lo8(63)
  65               	.LVL3:
 345:uart.c        ****     
 346:uart.c        ****     if ( tmphead == UART_RxTail ) {
  66               		.loc 1 346 0
  67 0026 2091 0000 		lds r18,UART_RxTail
  68 002a E217      		cp r30,r18
  69 002c 01F0      		breq .L3
 347:uart.c        ****         /* error: receive buffer overflow */
 348:uart.c        ****         lastRxError = UART_BUFFER_OVERFLOW >> 8;
 349:uart.c        ****     }else{
 350:uart.c        ****         /* store new index */
 351:uart.c        ****         UART_RxHead = tmphead;
  70               		.loc 1 351 0
  71 002e E093 0000 		sts UART_RxHead,r30
 352:uart.c        ****         /* store received data in buffer */
 353:uart.c        ****         UART_RxBuf[tmphead] = data;
  72               		.loc 1 353 0
  73 0032 F0E0      		ldi r31,0
  74 0034 E050      		subi r30,lo8(-(UART_RxBuf))
  75 0036 F040      		sbci r31,hi8(-(UART_RxBuf))
  76               	.LVL4:
  77 0038 9083      		st Z,r25
  78               	.LVL5:
  79 003a 00C0      		rjmp .L2
  80               	.LVL6:
  81               	.L3:
 348:uart.c        ****     }else{
  82               		.loc 1 348 0
  83 003c 82E0      		ldi r24,lo8(2)
  84               	.LVL7:
  85               	.L2:
 354:uart.c        ****     }
 355:uart.c        ****     UART_LastRxError = lastRxError;   		
  86               		.loc 1 355 0
  87 003e 8093 0000 		sts UART_LastRxError,r24
  88               	/* epilogue start */
 356:uart.c        **** }
  89               		.loc 1 356 0
  90 0042 FF91      		pop r31
  91 0044 EF91      		pop r30
  92 0046 9F91      		pop r25
  93               	.LVL8:
  94 0048 8F91      		pop r24
  95               	.LVL9:
  96 004a 2F91      		pop r18
  97 004c 0F90      		pop r0
  98 004e 0FBE      		out __SREG__,r0
  99               	.LVL10:
 100 0050 0F90      		pop r0
 101 0052 1F90      		pop r1
 102 0054 1895      		reti
 103               		.cfi_endproc
 104               	.LFE1:
 106               	.global	__vector_19
 108               	__vector_19:
 109               	.LFB2:
 357:uart.c        **** 
 358:uart.c        **** 
 359:uart.c        **** ISR(UART0_TRANSMIT_INTERRUPT)
 360:uart.c        **** /*************************************************************************
 361:uart.c        **** Function: UART Data Register Empty interrupt
 362:uart.c        **** Purpose:  called when the UART is ready to transmit the next byte
 363:uart.c        **** **************************************************************************/
 364:uart.c        **** {
 110               		.loc 1 364 0
 111               		.cfi_startproc
 112 0056 1F92      		push r1
 113               	.LCFI7:
 114               		.cfi_def_cfa_offset 3
 115               		.cfi_offset 1, -2
 116 0058 0F92      		push r0
 117               	.LCFI8:
 118               		.cfi_def_cfa_offset 4
 119               		.cfi_offset 0, -3
 120 005a 0FB6      		in r0,__SREG__
 121 005c 0F92      		push r0
 122 005e 1124      		clr __zero_reg__
 123 0060 8F93      		push r24
 124               	.LCFI9:
 125               		.cfi_def_cfa_offset 5
 126               		.cfi_offset 24, -4
 127 0062 9F93      		push r25
 128               	.LCFI10:
 129               		.cfi_def_cfa_offset 6
 130               		.cfi_offset 25, -5
 131 0064 EF93      		push r30
 132               	.LCFI11:
 133               		.cfi_def_cfa_offset 7
 134               		.cfi_offset 30, -6
 135 0066 FF93      		push r31
 136               	.LCFI12:
 137               		.cfi_def_cfa_offset 8
 138               		.cfi_offset 31, -7
 139               	/* prologue: Signal */
 140               	/* frame size = 0 */
 141               	/* stack size = 7 */
 142               	.L__stack_usage = 7
 365:uart.c        ****     unsigned char tmptail;
 366:uart.c        **** 
 367:uart.c        ****     
 368:uart.c        ****     if ( UART_TxHead != UART_TxTail) {
 143               		.loc 1 368 0
 144 0068 9091 0000 		lds r25,UART_TxHead
 145 006c 8091 0000 		lds r24,UART_TxTail
 146 0070 9817      		cp r25,r24
 147 0072 01F0      		breq .L6
 369:uart.c        ****         /* calculate and store new buffer index */
 370:uart.c        ****         tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
 148               		.loc 1 370 0
 149 0074 E091 0000 		lds r30,UART_TxTail
 150 0078 EF5F      		subi r30,lo8(-(1))
 151 007a EF73      		andi r30,lo8(63)
 152               	.LVL11:
 371:uart.c        ****         UART_TxTail = tmptail;
 153               		.loc 1 371 0
 154 007c E093 0000 		sts UART_TxTail,r30
 372:uart.c        ****         /* get one byte from buffer and write it to UART */
 373:uart.c        ****         UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
 155               		.loc 1 373 0
 156 0080 F0E0      		ldi r31,0
 157 0082 E050      		subi r30,lo8(-(UART_TxBuf))
 158 0084 F040      		sbci r31,hi8(-(UART_TxBuf))
 159               	.LVL12:
 160 0086 8081      		ld r24,Z
 161 0088 8093 C600 		sts 198,r24
 162               	.LVL13:
 163 008c 00C0      		rjmp .L5
 164               	.L6:
 374:uart.c        ****     }else{
 375:uart.c        ****         /* tx buffer empty, disable UDRE interrupt */
 376:uart.c        ****         UART0_CONTROL &= ~_BV(UART0_UDRIE);
 165               		.loc 1 376 0
 166 008e 8091 C100 		lds r24,193
 167 0092 8F7D      		andi r24,lo8(-33)
 168 0094 8093 C100 		sts 193,r24
 169               	.L5:
 170               	/* epilogue start */
 377:uart.c        ****     }
 378:uart.c        **** }
 171               		.loc 1 378 0
 172 0098 FF91      		pop r31
 173 009a EF91      		pop r30
 174 009c 9F91      		pop r25
 175 009e 8F91      		pop r24
 176 00a0 0F90      		pop r0
 177 00a2 0FBE      		out __SREG__,r0
 178 00a4 0F90      		pop r0
 179 00a6 1F90      		pop r1
 180 00a8 1895      		reti
 181               		.cfi_endproc
 182               	.LFE2:
 184               	.global	uart_init
 186               	uart_init:
 187               	.LFB3:
 379:uart.c        **** 
 380:uart.c        **** 
 381:uart.c        **** /*************************************************************************
 382:uart.c        **** Function: uart_init()
 383:uart.c        **** Purpose:  initialize UART and set baudrate
 384:uart.c        **** Input:    baudrate using macro UART_BAUD_SELECT()
 385:uart.c        **** Returns:  none
 386:uart.c        **** **************************************************************************/
 387:uart.c        **** void uart_init(unsigned int baudrate)
 388:uart.c        **** {
 188               		.loc 1 388 0
 189               		.cfi_startproc
 190               	.LVL14:
 191               	/* prologue: function */
 192               	/* frame size = 0 */
 193               	/* stack size = 0 */
 194               	.L__stack_usage = 0
 389:uart.c        ****     UART_TxHead = 0;
 195               		.loc 1 389 0
 196 00aa 1092 0000 		sts UART_TxHead,__zero_reg__
 390:uart.c        ****     UART_TxTail = 0;
 197               		.loc 1 390 0
 198 00ae 1092 0000 		sts UART_TxTail,__zero_reg__
 391:uart.c        ****     UART_RxHead = 0;
 199               		.loc 1 391 0
 200 00b2 1092 0000 		sts UART_RxHead,__zero_reg__
 392:uart.c        ****     UART_RxTail = 0;
 201               		.loc 1 392 0
 202 00b6 1092 0000 		sts UART_RxTail,__zero_reg__
 393:uart.c        ****     
 394:uart.c        **** #if defined( AT90_UART )
 395:uart.c        ****     /* set baud rate */
 396:uart.c        ****     UBRR = (unsigned char)baudrate; 
 397:uart.c        **** 
 398:uart.c        ****     /* enable UART receiver and transmmitter and receive complete interrupt */
 399:uart.c        ****     UART0_CONTROL = _BV(RXCIE)|_BV(RXEN)|_BV(TXEN);
 400:uart.c        **** 
 401:uart.c        **** #elif defined (ATMEGA_USART)
 402:uart.c        ****     /* Set baud rate */
 403:uart.c        ****     if ( baudrate & 0x8000 )
 404:uart.c        ****     {
 405:uart.c        ****     	 UART0_STATUS = (1<<U2X);  //Enable 2x speed 
 406:uart.c        ****     	 baudrate &= ~0x8000;
 407:uart.c        ****     }
 408:uart.c        ****     UBRRH = (unsigned char)(baudrate>>8);
 409:uart.c        ****     UBRRL = (unsigned char) baudrate;
 410:uart.c        ****    
 411:uart.c        ****     /* Enable USART receiver and transmitter and receive complete interrupt */
 412:uart.c        ****     UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);
 413:uart.c        ****     
 414:uart.c        ****     /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
 415:uart.c        ****     #ifdef URSEL
 416:uart.c        ****     UCSRC = (1<<URSEL)|(3<<UCSZ0);
 417:uart.c        ****     #else
 418:uart.c        ****     UCSRC = (3<<UCSZ0);
 419:uart.c        ****     #endif 
 420:uart.c        ****     
 421:uart.c        **** #elif defined (ATMEGA_USART0 )
 422:uart.c        ****     /* Set baud rate */
 423:uart.c        ****     if ( baudrate & 0x8000 ) 
 203               		.loc 1 423 0
 204 00ba 97FF      		sbrs r25,7
 205 00bc 00C0      		rjmp .L9
 424:uart.c        ****     {
 425:uart.c        ****    		UART0_STATUS = (1<<U2X0);  //Enable 2x speed 
 206               		.loc 1 425 0
 207 00be 22E0      		ldi r18,lo8(2)
 208 00c0 2093 C000 		sts 192,r18
 426:uart.c        ****    		baudrate &= ~0x8000;
 209               		.loc 1 426 0
 210 00c4 9F77      		andi r25,127
 211               	.LVL15:
 212               	.L9:
 427:uart.c        ****    	}
 428:uart.c        ****     UBRR0H = (unsigned char)(baudrate>>8);
 213               		.loc 1 428 0
 214 00c6 9093 C500 		sts 197,r25
 429:uart.c        ****     UBRR0L = (unsigned char) baudrate;
 215               		.loc 1 429 0
 216 00ca 8093 C400 		sts 196,r24
 430:uart.c        **** 
 431:uart.c        ****     /* Enable USART receiver and transmitter and receive complete interrupt */
 432:uart.c        ****     UART0_CONTROL = _BV(RXCIE0)|(1<<RXEN0)|(1<<TXEN0);
 217               		.loc 1 432 0
 218 00ce 88E9      		ldi r24,lo8(-104)
 219               	.LVL16:
 220 00d0 8093 C100 		sts 193,r24
 433:uart.c        ****     
 434:uart.c        ****     /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
 435:uart.c        ****     #ifdef URSEL0
 436:uart.c        ****     UCSR0C = (1<<URSEL0)|(3<<UCSZ00);
 437:uart.c        ****     #else
 438:uart.c        ****     UCSR0C = (3<<UCSZ00);
 221               		.loc 1 438 0
 222 00d4 86E0      		ldi r24,lo8(6)
 223 00d6 8093 C200 		sts 194,r24
 224 00da 0895      		ret
 225               		.cfi_endproc
 226               	.LFE3:
 228               	.global	uart_getc
 230               	uart_getc:
 231               	.LFB4:
 439:uart.c        ****     #endif 
 440:uart.c        **** 
 441:uart.c        **** #elif defined ( ATMEGA_UART )
 442:uart.c        ****     /* set baud rate */
 443:uart.c        ****     if ( baudrate & 0x8000 ) 
 444:uart.c        ****     {
 445:uart.c        ****     	UART0_STATUS = (1<<U2X);  //Enable 2x speed 
 446:uart.c        ****     	baudrate &= ~0x8000;
 447:uart.c        ****     }
 448:uart.c        ****     UBRRHI = (unsigned char)(baudrate>>8);
 449:uart.c        ****     UBRR   = (unsigned char) baudrate;
 450:uart.c        **** 
 451:uart.c        ****     /* Enable UART receiver and transmitter and receive complete interrupt */
 452:uart.c        ****     UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);
 453:uart.c        **** 
 454:uart.c        **** #endif
 455:uart.c        **** 
 456:uart.c        **** }/* uart_init */
 457:uart.c        **** 
 458:uart.c        **** 
 459:uart.c        **** /*************************************************************************
 460:uart.c        **** Function: uart_getc()
 461:uart.c        **** Purpose:  return byte from ringbuffer  
 462:uart.c        **** Returns:  lower byte:  received byte from ringbuffer
 463:uart.c        ****           higher byte: last receive error
 464:uart.c        **** **************************************************************************/
 465:uart.c        **** unsigned int uart_getc(void)
 466:uart.c        **** {    
 232               		.loc 1 466 0
 233               		.cfi_startproc
 234               	/* prologue: function */
 235               	/* frame size = 0 */
 236               	/* stack size = 0 */
 237               	.L__stack_usage = 0
 467:uart.c        ****     unsigned char tmptail;
 468:uart.c        ****     unsigned char data;
 469:uart.c        **** 
 470:uart.c        **** 
 471:uart.c        ****     if ( UART_RxHead == UART_RxTail ) {
 238               		.loc 1 471 0
 239 00dc 9091 0000 		lds r25,UART_RxHead
 240 00e0 8091 0000 		lds r24,UART_RxTail
 241 00e4 9817      		cp r25,r24
 242 00e6 01F0      		breq .L12
 472:uart.c        ****         return UART_NO_DATA;   /* no data available */
 473:uart.c        ****     }
 474:uart.c        ****     
 475:uart.c        ****     /* calculate /store buffer index */
 476:uart.c        ****     tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;
 243               		.loc 1 476 0
 244 00e8 E091 0000 		lds r30,UART_RxTail
 245 00ec EF5F      		subi r30,lo8(-(1))
 246 00ee EF73      		andi r30,lo8(63)
 247               	.LVL17:
 477:uart.c        ****     UART_RxTail = tmptail; 
 248               		.loc 1 477 0
 249 00f0 E093 0000 		sts UART_RxTail,r30
 478:uart.c        ****     
 479:uart.c        ****     /* get data from receive buffer */
 480:uart.c        ****     data = UART_RxBuf[tmptail];
 250               		.loc 1 480 0
 251 00f4 F0E0      		ldi r31,0
 252 00f6 E050      		subi r30,lo8(-(UART_RxBuf))
 253 00f8 F040      		sbci r31,hi8(-(UART_RxBuf))
 254               	.LVL18:
 255 00fa 2081      		ld r18,Z
 256               	.LVL19:
 481:uart.c        ****     
 482:uart.c        ****     return (UART_LastRxError << 8) + data;
 257               		.loc 1 482 0
 258 00fc 8091 0000 		lds r24,UART_LastRxError
 259 0100 90E0      		ldi r25,0
 260 0102 982F      		mov r25,r24
 261 0104 8827      		clr r24
 262 0106 820F      		add r24,r18
 263 0108 911D      		adc r25,__zero_reg__
 264 010a 0895      		ret
 265               	.LVL20:
 266               	.L12:
 472:uart.c        ****     }
 267               		.loc 1 472 0
 268 010c 80E0      		ldi r24,0
 269 010e 91E0      		ldi r25,lo8(1)
 483:uart.c        **** 
 484:uart.c        **** }/* uart_getc */
 270               		.loc 1 484 0
 271 0110 0895      		ret
 272               		.cfi_endproc
 273               	.LFE4:
 275               	.global	uart_putc
 277               	uart_putc:
 278               	.LFB5:
 485:uart.c        **** 
 486:uart.c        **** 
 487:uart.c        **** /*************************************************************************
 488:uart.c        **** Function: uart_putc()
 489:uart.c        **** Purpose:  write byte to ringbuffer for transmitting via UART
 490:uart.c        **** Input:    byte to be transmitted
 491:uart.c        **** Returns:  none          
 492:uart.c        **** **************************************************************************/
 493:uart.c        **** void uart_putc(unsigned char data)
 494:uart.c        **** {
 279               		.loc 1 494 0
 280               		.cfi_startproc
 281               	.LVL21:
 282               	/* prologue: function */
 283               	/* frame size = 0 */
 284               	/* stack size = 0 */
 285               	.L__stack_usage = 0
 495:uart.c        ****     unsigned char tmphead;
 496:uart.c        ****     
 497:uart.c        ****     tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
 286               		.loc 1 497 0
 287 0112 9091 0000 		lds r25,UART_TxHead
 288 0116 9F5F      		subi r25,lo8(-(1))
 289 0118 9F73      		andi r25,lo8(63)
 290               	.LVL22:
 291               	.L14:
 498:uart.c        ****     
 499:uart.c        ****     while ( tmphead == UART_TxTail ){
 292               		.loc 1 499 0 discriminator 1
 293 011a 2091 0000 		lds r18,UART_TxTail
 294 011e 9217      		cp r25,r18
 295 0120 01F0      		breq .L14
 500:uart.c        ****         ;/* wait for free space in buffer */
 501:uart.c        ****     }
 502:uart.c        ****     
 503:uart.c        ****     UART_TxBuf[tmphead] = data;
 296               		.loc 1 503 0
 297 0122 E92F      		mov r30,r25
 298 0124 F0E0      		ldi r31,0
 299 0126 E050      		subi r30,lo8(-(UART_TxBuf))
 300 0128 F040      		sbci r31,hi8(-(UART_TxBuf))
 301 012a 8083      		st Z,r24
 504:uart.c        ****     UART_TxHead = tmphead;
 302               		.loc 1 504 0
 303 012c 9093 0000 		sts UART_TxHead,r25
 505:uart.c        **** 
 506:uart.c        ****     /* enable UDRE interrupt */
 507:uart.c        ****     UART0_CONTROL    |= _BV(UART0_UDRIE);
 304               		.loc 1 507 0
 305 0130 8091 C100 		lds r24,193
 306               	.LVL23:
 307 0134 8062      		ori r24,lo8(32)
 308 0136 8093 C100 		sts 193,r24
 309 013a 0895      		ret
 310               		.cfi_endproc
 311               	.LFE5:
 313               	.global	uart_puts
 315               	uart_puts:
 316               	.LFB6:
 508:uart.c        **** 
 509:uart.c        **** }/* uart_putc */
 510:uart.c        **** 
 511:uart.c        **** 
 512:uart.c        **** /*************************************************************************
 513:uart.c        **** Function: uart_puts()
 514:uart.c        **** Purpose:  transmit string to UART
 515:uart.c        **** Input:    string to be transmitted
 516:uart.c        **** Returns:  none          
 517:uart.c        **** **************************************************************************/
 518:uart.c        **** void uart_puts(const char *s )
 519:uart.c        **** {
 317               		.loc 1 519 0
 318               		.cfi_startproc
 319               	.LVL24:
 320 013c CF93      		push r28
 321               	.LCFI13:
 322               		.cfi_def_cfa_offset 3
 323               		.cfi_offset 28, -2
 324 013e DF93      		push r29
 325               	.LCFI14:
 326               		.cfi_def_cfa_offset 4
 327               		.cfi_offset 29, -3
 328               	/* prologue: function */
 329               	/* frame size = 0 */
 330               	/* stack size = 2 */
 331               	.L__stack_usage = 2
 332 0140 EC01      		movw r28,r24
 333               	.LVL25:
 334               	.L17:
 520:uart.c        ****     while (*s) 
 335               		.loc 1 520 0
 336 0142 8991      		ld r24,Y+
 337               	.LVL26:
 338 0144 8823      		tst r24
 339 0146 01F0      		breq .L19
 340               	.LVL27:
 521:uart.c        ****       uart_putc(*s++);
 341               		.loc 1 521 0
 342 0148 00D0      		rcall uart_putc
 343               	.LVL28:
 344 014a 00C0      		rjmp .L17
 345               	.LVL29:
 346               	.L19:
 347               	/* epilogue start */
 522:uart.c        **** 
 523:uart.c        **** }/* uart_puts */
 348               		.loc 1 523 0
 349 014c DF91      		pop r29
 350 014e CF91      		pop r28
 351               	.LVL30:
 352 0150 0895      		ret
 353               		.cfi_endproc
 354               	.LFE6:
 356               	.global	uart_puts_p
 358               	uart_puts_p:
 359               	.LFB7:
 524:uart.c        **** 
 525:uart.c        **** 
 526:uart.c        **** /*************************************************************************
 527:uart.c        **** Function: uart_puts_p()
 528:uart.c        **** Purpose:  transmit string from program memory to UART
 529:uart.c        **** Input:    program memory string to be transmitted
 530:uart.c        **** Returns:  none
 531:uart.c        **** **************************************************************************/
 532:uart.c        **** void uart_puts_p(const char *progmem_s )
 533:uart.c        **** {
 360               		.loc 1 533 0
 361               		.cfi_startproc
 362               	.LVL31:
 363 0152 CF93      		push r28
 364               	.LCFI15:
 365               		.cfi_def_cfa_offset 3
 366               		.cfi_offset 28, -2
 367 0154 DF93      		push r29
 368               	.LCFI16:
 369               		.cfi_def_cfa_offset 4
 370               		.cfi_offset 29, -3
 371               	/* prologue: function */
 372               	/* frame size = 0 */
 373               	/* stack size = 2 */
 374               	.L__stack_usage = 2
 375 0156 FC01      		movw r30,r24
 376               	.LVL32:
 377               	.L21:
 378               	.LBB2:
 534:uart.c        ****     register char c;
 535:uart.c        ****     
 536:uart.c        ****     while ( (c = pgm_read_byte(progmem_s++)) ) 
 379               		.loc 1 536 0
 380               	/* #APP */
 381               	 ;  536 "uart.c" 1
 382 0158 8491      		lpm r24, Z
 383               		
 384               	 ;  0 "" 2
 385               	.LVL33:
 386               	/* #NOAPP */
 387 015a EF01      		movw r28,r30
 388 015c 2196      		adiw r28,1
 389               	.LVL34:
 390               	.LBE2:
 391 015e 8823      		tst r24
 392 0160 01F0      		breq .L23
 537:uart.c        ****       uart_putc(c);
 393               		.loc 1 537 0
 394 0162 00D0      		rcall uart_putc
 395               	.LVL35:
 396 0164 FE01      		movw r30,r28
 397 0166 00C0      		rjmp .L21
 398               	.LVL36:
 399               	.L23:
 400               	/* epilogue start */
 538:uart.c        **** 
 539:uart.c        **** }/* uart_puts_p */
 401               		.loc 1 539 0
 402 0168 DF91      		pop r29
 403 016a CF91      		pop r28
 404               	.LVL37:
 405 016c 0895      		ret
 406               		.cfi_endproc
 407               	.LFE7:
 409               	.global	uart_putc_arr
 411               	uart_putc_arr:
 412               	.LFB8:
 540:uart.c        **** 
 541:uart.c        **** 
 542:uart.c        **** /*************************************************************************
 543:uart.c        **** Function: uart_putc_arr()
 544:uart.c        **** Purpose:  transmit string to UART
 545:uart.c        **** Input:    string to be transmitted
 546:uart.c        **** Returns:  none          
 547:uart.c        **** **************************************************************************/
 548:uart.c        **** void uart_putc_arr(const char *s, unsigned char length)
 549:uart.c        **** {
 413               		.loc 1 549 0
 414               		.cfi_startproc
 415               	.LVL38:
 416 016e EF92      		push r14
 417               	.LCFI17:
 418               		.cfi_def_cfa_offset 3
 419               		.cfi_offset 14, -2
 420 0170 FF92      		push r15
 421               	.LCFI18:
 422               		.cfi_def_cfa_offset 4
 423               		.cfi_offset 15, -3
 424 0172 0F93      		push r16
 425               	.LCFI19:
 426               		.cfi_def_cfa_offset 5
 427               		.cfi_offset 16, -4
 428 0174 1F93      		push r17
 429               	.LCFI20:
 430               		.cfi_def_cfa_offset 6
 431               		.cfi_offset 17, -5
 432 0176 CF93      		push r28
 433               	.LCFI21:
 434               		.cfi_def_cfa_offset 7
 435               		.cfi_offset 28, -6
 436 0178 DF93      		push r29
 437               	.LCFI22:
 438               		.cfi_def_cfa_offset 8
 439               		.cfi_offset 29, -7
 440               	/* prologue: function */
 441               	/* frame size = 0 */
 442               	/* stack size = 6 */
 443               	.L__stack_usage = 6
 444 017a 7C01      		movw r14,r24
 445               	.LVL39:
 550:uart.c        **** 	int i;
 551:uart.c        **** 
 552:uart.c        ****     for(i = 0; i < length; ++i)
 446               		.loc 1 552 0
 447 017c 8C01      		movw r16,r24
 448 017e C62F      		mov r28,r22
 449 0180 D0E0      		ldi r29,0
 450               	.LVL40:
 451               	.L25:
 452               		.loc 1 552 0 is_stmt 0 discriminator 1
 453 0182 C801      		movw r24,r16
 454 0184 8E19      		sub r24,r14
 455 0186 9F09      		sbc r25,r15
 456 0188 8C17      		cp r24,r28
 457 018a 9D07      		cpc r25,r29
 458 018c 04F4      		brge .L27
 459               	.LVL41:
 553:uart.c        ****       uart_putc(*s++);
 460               		.loc 1 553 0 is_stmt 1 discriminator 3
 461 018e F801      		movw r30,r16
 462 0190 8191      		ld r24,Z+
 463               	.LVL42:
 464 0192 8F01      		movw r16,r30
 465               	.LVL43:
 466 0194 00D0      		rcall uart_putc
 467               	.LVL44:
 468 0196 00C0      		rjmp .L25
 469               	.L27:
 470               	/* epilogue start */
 554:uart.c        **** 
 555:uart.c        **** }/* uart_putc_arr */
 471               		.loc 1 555 0
 472 0198 DF91      		pop r29
 473 019a CF91      		pop r28
 474               	.LVL45:
 475 019c 1F91      		pop r17
 476 019e 0F91      		pop r16
 477               	.LVL46:
 478 01a0 FF90      		pop r15
 479 01a2 EF90      		pop r14
 480 01a4 0895      		ret
 481               		.cfi_endproc
 482               	.LFE8:
 484               	.global	uart_available
 486               	uart_available:
 487               	.LFB9:
 556:uart.c        **** 
 557:uart.c        **** 
 558:uart.c        **** 
 559:uart.c        **** /*************************************************************************
 560:uart.c        **** Function: uart_available()
 561:uart.c        **** Purpose:  Determine the number of bytes waiting in the receive buffer
 562:uart.c        **** Input:    None
 563:uart.c        **** Returns:  Integer number of bytes in the receive buffer
 564:uart.c        **** **************************************************************************/
 565:uart.c        **** int uart_available(void)
 566:uart.c        **** {
 488               		.loc 1 566 0
 489               		.cfi_startproc
 490               	/* prologue: function */
 491               	/* frame size = 0 */
 492               	/* stack size = 0 */
 493               	.L__stack_usage = 0
 567:uart.c        **** 		if((UART_RxHead & UART_RX_BUFFER_MASK) >= (UART_RxTail & UART_RX_BUFFER_MASK))
 494               		.loc 1 567 0
 495 01a6 2091 0000 		lds r18,UART_RxHead
 496 01aa 8091 0000 		lds r24,UART_RxTail
 497 01ae 2F73      		andi r18,lo8(63)
 498 01b0 30E0      		ldi r19,0
 499 01b2 8F73      		andi r24,lo8(63)
 500 01b4 90E0      		ldi r25,0
 501 01b6 2817      		cp r18,r24
 502 01b8 3907      		cpc r19,r25
 503 01ba 04F0      		brlt .L29
 568:uart.c        **** 		{
 569:uart.c        **** 			return (UART_RxHead & UART_RX_BUFFER_MASK) - (UART_RxTail & UART_RX_BUFFER_MASK);
 504               		.loc 1 569 0
 505 01bc 8091 0000 		lds r24,UART_RxHead
 506 01c0 2091 0000 		lds r18,UART_RxTail
 507 01c4 8F73      		andi r24,lo8(63)
 508 01c6 90E0      		ldi r25,0
 509 01c8 00C0      		rjmp .L31
 510               	.L29:
 570:uart.c        **** 		}
 571:uart.c        **** 		else
 572:uart.c        **** 		{
 573:uart.c        **** 			return UART_RX_BUFFER_SIZE + (UART_RxHead & UART_RX_BUFFER_MASK) - (UART_RxTail & UART_RX_BUFFER
 511               		.loc 1 573 0
 512 01ca 8091 0000 		lds r24,UART_RxHead
 513 01ce 2091 0000 		lds r18,UART_RxTail
 514 01d2 8F73      		andi r24,lo8(63)
 515 01d4 90E0      		ldi r25,0
 516 01d6 805C      		subi r24,-64
 517 01d8 9F4F      		sbci r25,-1
 518               	.L31:
 519 01da 2F73      		andi r18,lo8(63)
 520 01dc 821B      		sub r24,r18
 521 01de 9109      		sbc r25,__zero_reg__
 574:uart.c        **** 		}
 575:uart.c        **** 
 576:uart.c        ****         //return (UART_RX_BUFFER_MASK + UART_RxHead - UART_RxTail) % UART_RX_BUFFER_MASK;
 577:uart.c        **** 		
 578:uart.c        **** }/* uart_available */
 522               		.loc 1 578 0
 523 01e0 0895      		ret
 524               		.cfi_endproc
 525               	.LFE9:
 527               	.global	uart_flush
 529               	uart_flush:
 530               	.LFB10:
 579:uart.c        **** 
 580:uart.c        **** 
 581:uart.c        **** 
 582:uart.c        **** /*************************************************************************
 583:uart.c        **** Function: uart_flush()
 584:uart.c        **** Purpose:  Flush bytes waiting the receive buffer.  Acutally ignores them.
 585:uart.c        **** Input:    None
 586:uart.c        **** Returns:  None
 587:uart.c        **** **************************************************************************/
 588:uart.c        **** void uart_flush(void)
 589:uart.c        **** {
 531               		.loc 1 589 0
 532               		.cfi_startproc
 533               	/* prologue: function */
 534               	/* frame size = 0 */
 535               	/* stack size = 0 */
 536               	.L__stack_usage = 0
 590:uart.c        ****         UART_RxHead = UART_RxTail;
 537               		.loc 1 590 0
 538 01e2 8091 0000 		lds r24,UART_RxTail
 539 01e6 8093 0000 		sts UART_RxHead,r24
 540 01ea 0895      		ret
 541               		.cfi_endproc
 542               	.LFE10:
 544               		.local	UART_LastRxError
 545               		.comm	UART_LastRxError,1,1
 546               		.local	UART_RxTail
 547               		.comm	UART_RxTail,1,1
 548               		.local	UART_RxHead
 549               		.comm	UART_RxHead,1,1
 550               		.local	UART_TxTail
 551               		.comm	UART_TxTail,1,1
 552               		.local	UART_TxHead
 553               		.comm	UART_TxHead,1,1
 554               		.local	UART_RxBuf
 555               		.comm	UART_RxBuf,64,1
 556               		.local	UART_TxBuf
 557               		.comm	UART_TxBuf,64,1
 558               	.Letext0:
 559               		.file 2 "c:\\winavr-20100110\\avr\\include\\stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 uart.c
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:2      *ABS*:0000003e __SP_H__
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:3      *ABS*:0000003d __SP_L__
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:4      *ABS*:0000003f __SREG__
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:6      *ABS*:00000001 __zero_reg__
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:12     .text:00000000 __vector_18
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:547    .bss:00000002 UART_RxHead
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:545    .bss:00000001 UART_RxTail
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:553    .bss:00000005 UART_RxBuf
                             .bss:00000000 UART_LastRxError
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:108    .text:00000056 __vector_19
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:551    .bss:00000004 UART_TxHead
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:549    .bss:00000003 UART_TxTail
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:555    .bss:00000045 UART_TxBuf
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:186    .text:000000aa uart_init
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:230    .text:000000dc uart_getc
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:277    .text:00000112 uart_putc
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:315    .text:0000013c uart_puts
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:358    .text:00000152 uart_puts_p
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:411    .text:0000016e uart_putc_arr
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:486    .text:000001a6 uart_available
C:\Users\mcmai\AppData\Local\Temp\ccFxsjeH.s:529    .text:000001e2 uart_flush

UNDEFINED SYMBOLS
__do_clear_bss
