   1               		.file	"states.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	STATE_error__handler
  12               	STATE_error__handler:
  13               	.LFB6:
  14               		.file 1 "states.c"
   1:states.c      **** /*
   2:states.c      **** 	Copyright (c) 2022 by Martin Maier (martin@mcmaier.net)
   3:states.c      **** 	
   4:states.c      ****     Permission is hereby granted, free of charge, to any person 
   5:states.c      ****     obtaining a copy of this software and associated documentation 
   6:states.c      ****     files (the "Software"), to deal in the Software without 
   7:states.c      ****     restriction, including without limitation the rights to use, copy, 
   8:states.c      ****     modify, merge, publish, distribute, sublicense, and/or sell copies 
   9:states.c      ****     of the Software, and to permit persons to whom the Software is 
  10:states.c      ****     furnished to do so, subject to the following conditions:
  11:states.c      **** 
  12:states.c      ****     The above copyright notice and this permission notice shall be 
  13:states.c      ****     included in all copies or substantial portions of the Software.
  14:states.c      **** 
  15:states.c      ****     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
  16:states.c      ****     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
  17:states.c      ****     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
  18:states.c      ****     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
  19:states.c      ****     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
  20:states.c      ****     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
  21:states.c      ****     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
  22:states.c      ****     DEALINGS IN THE SOFTWARE.    
  23:states.c      **** */
  24:states.c      ****  
  25:states.c      **** #include <util/delay.h>
  26:states.c      **** #include <avr/sleep.h>
  27:states.c      **** 
  28:states.c      **** #include "statemachine.h"
  29:states.c      **** //#include "ringbuffer.h"
  30:states.c      **** //#include "hardware.h"
  31:states.c      **** //#include "calculation.h"
  32:states.c      **** //#include "uart.h"
  33:states.c      **** //#include "spi.h"
  34:states.c      **** //#include "nRF24L01.h"
  35:states.c      **** //#include "wl_module.h"
  36:states.c      **** 
  37:states.c      **** extern volatile uint8_t PTX;
  38:states.c      **** static uint16_t timer;
  39:states.c      **** 
  40:states.c      **** //static uint8_t payload[16];
  41:states.c      **** 
  42:states.c      **** //----------------------------------------------------------
  43:states.c      **** // ERROR STATE HANDLER
  44:states.c      **** //---------------------------------------------------------
  45:states.c      **** 
  46:states.c      **** States_t STATE_error__handler(Events_t event)
  47:states.c      **** {
  15               		.loc 1 47 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  48:states.c      **** 	States_t ret_state = STATE_error;
  49:states.c      **** 
  50:states.c      **** 	switch(event)
  51:states.c      **** 	{	
  52:states.c      **** 		case EVENT_timer_tick:							
  53:states.c      **** 			ret_state = STATE_error;					
  54:states.c      **** 			break;
  55:states.c      **** 			
  56:states.c      **** 		default:
  57:states.c      **** 			break;
  58:states.c      **** 	}
  59:states.c      **** 	
  60:states.c      **** 	return ret_state;
  61:states.c      **** }	
  22               		.loc 1 61 0
  23 0000 80E0      		ldi r24,0
  24               	.LVL1:
  25 0002 0895      		ret
  26               		.cfi_endproc
  27               	.LFE6:
  29               	.global	STATE_start__handler
  31               	STATE_start__handler:
  32               	.LFB7:
  62:states.c      **** 
  63:states.c      **** 
  64:states.c      **** //----------------------------------------------------------
  65:states.c      **** // START STATE HANDLER
  66:states.c      **** //---------------------------------------------------------
  67:states.c      **** 
  68:states.c      **** States_t STATE_start__handler(Events_t event)
  69:states.c      **** {
  33               		.loc 1 69 0
  34               		.cfi_startproc
  35               	.LVL2:
  36               	/* prologue: function */
  37               	/* frame size = 0 */
  38               	/* stack size = 0 */
  39               	.L__stack_usage = 0
  70:states.c      **** 	States_t ret_state = STATE_start;
  71:states.c      **** 
  72:states.c      **** 	switch(event)
  73:states.c      **** 	{	
  74:states.c      **** 		case EVENT_timer_tick:							
  75:states.c      **** 				ret_state = STATE_start;					
  76:states.c      **** 			break;
  77:states.c      **** 			
  78:states.c      **** 		default:
  79:states.c      **** 			break;
  80:states.c      **** 	}
  81:states.c      **** 	
  82:states.c      **** 	return ret_state;
  83:states.c      **** }	
  40               		.loc 1 83 0
  41 0004 81E0      		ldi r24,lo8(1)
  42               	.LVL3:
  43 0006 0895      		ret
  44               		.cfi_endproc
  45               	.LFE7:
  47               	.global	STATE_init__handler
  49               	STATE_init__handler:
  50               	.LFB8:
  84:states.c      **** 
  85:states.c      **** 
  86:states.c      **** //----------------------------------------------------------
  87:states.c      **** // INIT STATE HANDLER
  88:states.c      **** //---------------------------------------------------------
  89:states.c      **** 
  90:states.c      **** States_t STATE_init__handler(Events_t event)
  91:states.c      **** {
  51               		.loc 1 91 0
  52               		.cfi_startproc
  53               	.LVL4:
  54               	/* prologue: function */
  55               	/* frame size = 0 */
  56               	/* stack size = 0 */
  57               	.L__stack_usage = 0
  92:states.c      **** 	States_t ret_state = STATE_init;
  93:states.c      **** 
  94:states.c      **** 	switch(event)
  95:states.c      **** 	{	
  96:states.c      **** 		case EVENT_timer_tick:							
  97:states.c      **** 			ret_state = STATE_init;					
  98:states.c      **** 			break;
  99:states.c      **** 			
 100:states.c      **** 		default:
 101:states.c      **** 			break;
 102:states.c      **** 	}
 103:states.c      **** 	
 104:states.c      **** 	return ret_state;
 105:states.c      **** }
  58               		.loc 1 105 0
  59 0008 82E0      		ldi r24,lo8(2)
  60               	.LVL5:
  61 000a 0895      		ret
  62               		.cfi_endproc
  63               	.LFE8:
  65               	.global	STATE_receive__handler
  67               	STATE_receive__handler:
  68               	.LFB9:
 106:states.c      **** 
 107:states.c      **** 
 108:states.c      **** //----------------------------------------------------------
 109:states.c      **** // RECEIVE STATE HANDLER
 110:states.c      **** //---------------------------------------------------------
 111:states.c      **** 
 112:states.c      **** States_t STATE_receive__handler(Events_t event)
 113:states.c      **** {
  69               		.loc 1 113 0
  70               		.cfi_startproc
  71               	.LVL6:
  72               	/* prologue: function */
  73               	/* frame size = 0 */
  74               	/* stack size = 0 */
  75               	.L__stack_usage = 0
 114:states.c      **** 	States_t ret_state = STATE_receive;
 115:states.c      **** 	
 116:states.c      **** 	/*
 117:states.c      **** 	switch(event)
 118:states.c      **** 	{	
 119:states.c      **** 		case EVENT_timer_tick:				
 120:states.c      **** 			if(timer++ == 0)
 121:states.c      **** 			{
 122:states.c      **** 				//LED1_ON;			
 123:states.c      **** 				configureSpi(SPI_MODE_NRF);
 124:states.c      **** 			}
 125:states.c      **** 			else if(timer == 5)
 126:states.c      **** 			{				
 127:states.c      **** 				wl_module_tx_config(wl_module_TX_NR_0);	
 128:states.c      **** 				wl_module_rx_config();	
 129:states.c      **** 			}
 130:states.c      **** 			else if(timer > 55)
 131:states.c      **** 			{				
 132:states.c      **** 				if(measureMode || writeMode)
 133:states.c      **** 				{
 134:states.c      **** 					wl_module_CE_lo;
 135:states.c      **** 					ret_state = STATE_batt_measure;
 136:states.c      **** 				}
 137:states.c      **** 				else
 138:states.c      **** 				{
 139:states.c      **** 					configureSpi(SPI_MODE_OFF);
 140:states.c      **** 					ret_state = STATE_batt_sleep;				
 141:states.c      **** 				}				
 142:states.c      **** 			}
 143:states.c      **** 			break;
 144:states.c      **** 			
 145:states.c      **** 		case EVENT_dataReceivedNRF:		
 146:states.c      **** 				if(wirelessRxBuf[0] == 'M')
 147:states.c      **** 				{
 148:states.c      **** 					measureMode = 1;
 149:states.c      **** 				}		
 150:states.c      **** 				else if(wirelessRxBuf[0] == 'm')
 151:states.c      **** 				{
 152:states.c      **** 					measureMode = 0;
 153:states.c      **** 				}
 154:states.c      **** 				else if(wirelessRxBuf[0] == 'W')
 155:states.c      **** 				{
 156:states.c      **** 					writeMode = 1;
 157:states.c      **** 				}
 158:states.c      **** 				else if(wirelessRxBuf[0] == 'w')
 159:states.c      **** 				{
 160:states.c      **** 					writeMode = 0;
 161:states.c      **** 				}
 162:states.c      **** 			break;
 163:states.c      **** 			
 164:states.c      **** 		default:
 165:states.c      **** 			break;
 166:states.c      **** 	}
 167:states.c      **** 	*/
 168:states.c      **** 	
 169:states.c      **** 	return ret_state;
 170:states.c      **** }	
  76               		.loc 1 170 0
  77 000c 83E0      		ldi r24,lo8(3)
  78               	.LVL7:
  79 000e 0895      		ret
  80               		.cfi_endproc
  81               	.LFE9:
  83               	.global	STATE_transmit__handler
  85               	STATE_transmit__handler:
  86               	.LFB10:
 171:states.c      **** 
 172:states.c      **** //----------------------------------------------------------
 173:states.c      **** // TRANSMIT STATE HANDLER
 174:states.c      **** //---------------------------------------------------------
 175:states.c      **** 
 176:states.c      **** States_t STATE_transmit__handler(Events_t event)
 177:states.c      **** {
  87               		.loc 1 177 0
  88               		.cfi_startproc
  89               	.LVL8:
  90               	/* prologue: function */
  91               	/* frame size = 0 */
  92               	/* stack size = 0 */
  93               	.L__stack_usage = 0
 178:states.c      **** 	States_t ret_state = STATE_transmit;
 179:states.c      **** 
 180:states.c      **** 	/*
 181:states.c      **** 
 182:states.c      **** 	switch(event)
 183:states.c      **** 	{	
 184:states.c      **** 		case EVENT_timer_tick:	
 185:states.c      **** 				
 186:states.c      **** 			if(timer++ == 0)
 187:states.c      **** 			{		
 188:states.c      **** 				LED1_ON
 189:states.c      **** 								
 190:states.c      **** 				//configureSpi(SPI_MODE_NRF);
 191:states.c      **** 	
 192:states.c      **** 				i2c_start(RTC_ADDRESS|I2C_WRITE);
 193:states.c      **** 				i2c_write(0x01);
 194:states.c      **** 				i2c_rep_start(RTC_ADDRESS|I2C_READ);
 195:states.c      **** 				payload[0] = i2c_readAck();
 196:states.c      **** 				payload[1] = i2c_readAck();
 197:states.c      **** 				payload[2] = i2c_readNak();
 198:states.c      **** 			}
 199:states.c      **** 			else if(timer == 2)
 200:states.c      **** 			{
 201:states.c      **** 				ADCSRA |= (1 << ADEN);
 202:states.c      **** 				LIGHT_MEAS_ON;
 203:states.c      **** 				ADC_Read(7);				
 204:states.c      **** 			}
 205:states.c      **** 			else if(timer == 3)
 206:states.c      **** 			{
 207:states.c      **** 				adc = ADC_Read(7);
 208:states.c      **** 				LIGHT_MEAS_OFF;
 209:states.c      **** 				
 210:states.c      **** 				payload[3] = (uint8_t)(adc & 0x00FF);
 211:states.c      **** 				payload[4] = (uint8_t)((adc & 0xFF00) >> 8);
 212:states.c      **** 				
 213:states.c      **** 				adc = ADC_Read(6);
 214:states.c      **** 			}
 215:states.c      **** 			else if(timer == 4)
 216:states.c      **** 			{
 217:states.c      **** 				adc = ADC_Read(6);
 218:states.c      **** 				ADCSRA &= ~(1 << ADEN);
 219:states.c      **** 				
 220:states.c      **** 				payload[5] = (uint8_t)(adc & 0x00FF);
 221:states.c      **** 				payload[6] = (uint8_t)((adc & 0xFF00) >> 8);
 222:states.c      **** 			}
 223:states.c      **** 			else if(timer == 5)
 224:states.c      **** 			{			
 225:states.c      **** 				//wl_module_rx_config();
 226:states.c      **** 				//wl_module_tx_config(wl_module_TX_NR_0);	
 227:states.c      **** 				
 228:states.c      **** 				if(measureMode)
 229:states.c      **** 				{
 230:states.c      **** 					wl_module_send(payload,wl_module_PAYLOAD);
 231:states.c      **** 				}
 232:states.c      **** 				
 233:states.c      **** 				if(writeMode)
 234:states.c      **** 				{
 235:states.c      **** 					parseData(payload,writeBuf[writeCount]);
 236:states.c      **** 				}
 237:states.c      **** 			}			
 238:states.c      **** 			else if((timer > 5) && !PTX)
 239:states.c      **** 			{			
 240:states.c      **** 				LED1_OFF
 241:states.c      **** 		
 242:states.c      **** 				if(writeMode)
 243:states.c      **** 				{
 244:states.c      **** 					if(writeCount++ > 4)
 245:states.c      **** 					{
 246:states.c      **** 						ret_state = STATE_batt_write;
 247:states.c      **** 						writeCount = 0;
 248:states.c      **** 					}
 249:states.c      **** 					else
 250:states.c      **** 					{
 251:states.c      **** 						ret_state = STATE_batt_sleep;
 252:states.c      **** 					}
 253:states.c      **** 				}
 254:states.c      **** 				else
 255:states.c      **** 				{
 256:states.c      **** 					ret_state = STATE_batt_sleep;
 257:states.c      **** 				}
 258:states.c      **** 			}
 259:states.c      **** 			else if(PTX && (timer > 50))
 260:states.c      **** 			{
 261:states.c      **** 				PTX = 0;
 262:states.c      **** 			}
 263:states.c      **** 			break;
 264:states.c      **** 			
 265:states.c      **** 		default:
 266:states.c      **** 			break;
 267:states.c      **** 	}
 268:states.c      **** 	
 269:states.c      **** 	if(ret_state == STATE_batt_sleep)
 270:states.c      **** 	{
 271:states.c      **** 		configureSpi(SPI_MODE_OFF);
 272:states.c      **** 	}
 273:states.c      **** 
 274:states.c      **** 	*/
 275:states.c      **** 	
 276:states.c      **** 	return ret_state;
 277:states.c      **** }	
  94               		.loc 1 277 0
  95 0010 84E0      		ldi r24,lo8(4)
  96               	.LVL9:
  97 0012 0895      		ret
  98               		.cfi_endproc
  99               	.LFE10:
 101               	.global	STATE_error__entering_handler
 103               	STATE_error__entering_handler:
 104               	.LFB23:
 105               		.cfi_startproc
 106               	/* prologue: function */
 107               	/* frame size = 0 */
 108               	/* stack size = 0 */
 109               	.L__stack_usage = 0
 110 0014 0895      		ret
 111               		.cfi_endproc
 112               	.LFE23:
 114               	.global	STATE_start__entering_handler
 116               	STATE_start__entering_handler:
 117               	.LFB21:
 118               		.cfi_startproc
 119               	/* prologue: function */
 120               	/* frame size = 0 */
 121               	/* stack size = 0 */
 122               	.L__stack_usage = 0
 123 0016 0895      		ret
 124               		.cfi_endproc
 125               	.LFE21:
 127               	.global	STATE_init__entering_handler
 129               	STATE_init__entering_handler:
 130               	.LFB19:
 131               		.cfi_startproc
 132               	/* prologue: function */
 133               	/* frame size = 0 */
 134               	/* stack size = 0 */
 135               	.L__stack_usage = 0
 136 0018 0895      		ret
 137               		.cfi_endproc
 138               	.LFE19:
 140               	.global	STATE_receive__entering_handler
 142               	STATE_receive__entering_handler:
 143               	.LFB17:
 144               		.cfi_startproc
 145               	/* prologue: function */
 146               	/* frame size = 0 */
 147               	/* stack size = 0 */
 148               	.L__stack_usage = 0
 149 001a 0895      		ret
 150               		.cfi_endproc
 151               	.LFE17:
 153               	.global	STATE_transmit__entering_handler
 155               	STATE_transmit__entering_handler:
 156               	.LFB15:
 278:states.c      **** 
 279:states.c      **** 
 280:states.c      **** //----------------------------------------------------------
 281:states.c      **** // STATE ENTRY FUNCTIONS
 282:states.c      **** //---------------------------------------------------------
 283:states.c      **** void STATE_error__entering_handler(void)
 284:states.c      **** {	
 285:states.c      **** 	timer = 0;
 286:states.c      **** }
 287:states.c      **** 
 288:states.c      **** 
 289:states.c      **** //---------------------------------------------------------
 290:states.c      **** void STATE_start__entering_handler(void)
 291:states.c      **** {	
 292:states.c      **** 	timer = 0;
 293:states.c      **** }
 294:states.c      **** 
 295:states.c      **** //---------------------------------------------------------
 296:states.c      **** void STATE_init__entering_handler(void)
 297:states.c      **** {	
 298:states.c      **** 	timer = 0;
 299:states.c      **** }
 300:states.c      **** 
 301:states.c      **** //---------------------------------------------------------
 302:states.c      **** void STATE_receive__entering_handler(void)
 303:states.c      **** {	
 304:states.c      **** 	timer = 0;
 305:states.c      **** }
 306:states.c      **** 
 307:states.c      **** 
 308:states.c      **** //---------------------------------------------------------
 309:states.c      **** void STATE_transmit__entering_handler(void)
 310:states.c      **** {
 157               		.loc 1 310 0
 158               		.cfi_startproc
 159               	/* prologue: function */
 160               	/* frame size = 0 */
 161               	/* stack size = 0 */
 162               	.L__stack_usage = 0
 163 001c 0895      		ret
 164               		.cfi_endproc
 165               	.LFE15:
 167               	.Letext0:
 168               		.file 2 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 169               		.file 3 "statemachine.h"
DEFINED SYMBOLS
                            *ABS*:00000000 states.c
C:\Users\mcmai\AppData\Local\Temp\ccJn7gty.s:2      *ABS*:0000003e __SP_H__
C:\Users\mcmai\AppData\Local\Temp\ccJn7gty.s:3      *ABS*:0000003d __SP_L__
C:\Users\mcmai\AppData\Local\Temp\ccJn7gty.s:4      *ABS*:0000003f __SREG__
C:\Users\mcmai\AppData\Local\Temp\ccJn7gty.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\mcmai\AppData\Local\Temp\ccJn7gty.s:6      *ABS*:00000001 __zero_reg__
C:\Users\mcmai\AppData\Local\Temp\ccJn7gty.s:12     .text:00000000 STATE_error__handler
C:\Users\mcmai\AppData\Local\Temp\ccJn7gty.s:31     .text:00000004 STATE_start__handler
C:\Users\mcmai\AppData\Local\Temp\ccJn7gty.s:49     .text:00000008 STATE_init__handler
C:\Users\mcmai\AppData\Local\Temp\ccJn7gty.s:67     .text:0000000c STATE_receive__handler
C:\Users\mcmai\AppData\Local\Temp\ccJn7gty.s:85     .text:00000010 STATE_transmit__handler
C:\Users\mcmai\AppData\Local\Temp\ccJn7gty.s:103    .text:00000014 STATE_error__entering_handler
C:\Users\mcmai\AppData\Local\Temp\ccJn7gty.s:116    .text:00000016 STATE_start__entering_handler
C:\Users\mcmai\AppData\Local\Temp\ccJn7gty.s:129    .text:00000018 STATE_init__entering_handler
C:\Users\mcmai\AppData\Local\Temp\ccJn7gty.s:142    .text:0000001a STATE_receive__entering_handler
C:\Users\mcmai\AppData\Local\Temp\ccJn7gty.s:155    .text:0000001c STATE_transmit__entering_handler

NO UNDEFINED SYMBOLS
