   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	__vector_1
  12               	__vector_1:
  13               	.LFB6:
  14               		.file 1 "main.c"
   1:main.c        **** /*																																										/*
   2:main.c        **** 	Copyright (c) 2022 by Martin Maier (martin@mcmaier.net)
   3:main.c        **** 	
   4:main.c        ****     Permission is hereby granted, free of charge, to any person 
   5:main.c        ****     obtaining a copy of this software and associated documentation 
   6:main.c        ****     files (the "Software"), to deal in the Software without 
   7:main.c        ****     restriction, including without limitation the rights to use, copy, 
   8:main.c        ****     modify, merge, publish, distribute, sublicense, and/or sell copies 
   9:main.c        ****     of the Software, and to permit persons to whom the Software is 
  10:main.c        ****     furnished to do so, subject to the following conditions:
  11:main.c        **** 
  12:main.c        ****     The above copyright notice and this permission notice shall be 
  13:main.c        ****     included in all copies or substantial portions of the Software.
  14:main.c        **** 
  15:main.c        ****     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
  16:main.c        ****     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
  17:main.c        ****     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
  18:main.c        ****     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
  19:main.c        ****     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
  20:main.c        ****     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
  21:main.c        ****     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
  22:main.c        ****     DEALINGS IN THE SOFTWARE.    
  23:main.c        **** 
  24:main.c        **** //---------------------------------------------------------------------
  25:main.c        **** // Code for AVR & NRF24 for communication with hoymiles microinverters
  26:main.c        **** //---------------------------------------------------------------------
  27:main.c        **** */
  28:main.c        **** 
  29:main.c        **** #include <avr/io.h>
  30:main.c        **** #include <avr/interrupt.h>
  31:main.c        **** #include <util/delay.h>
  32:main.c        **** 
  33:main.c        **** #include "statemachine.h"
  34:main.c        **** #include "hardware.h"
  35:main.c        **** #include "wl_module.h"
  36:main.c        **** #include "spi.h"
  37:main.c        **** #include "nRF24L01.h"
  38:main.c        **** #include "uart.h"
  39:main.c        **** #include "crc.h"
  40:main.c        **** 
  41:main.c        **** volatile uint8_t PTX;
  42:main.c        **** States_t main_state;
  43:main.c        **** 
  44:main.c        **** ISR(INT0_vect)
  45:main.c        **** {
  15               		.loc 1 45 0
  16               		.cfi_startproc
  17 0000 1F92      		push r1
  18               	.LCFI0:
  19               		.cfi_def_cfa_offset 3
  20               		.cfi_offset 1, -2
  21 0002 0F92      		push r0
  22               	.LCFI1:
  23               		.cfi_def_cfa_offset 4
  24               		.cfi_offset 0, -3
  25 0004 0FB6      		in r0,__SREG__
  26 0006 0F92      		push r0
  27 0008 1124      		clr __zero_reg__
  28 000a 2F93      		push r18
  29               	.LCFI2:
  30               		.cfi_def_cfa_offset 5
  31               		.cfi_offset 18, -4
  32 000c 3F93      		push r19
  33               	.LCFI3:
  34               		.cfi_def_cfa_offset 6
  35               		.cfi_offset 19, -5
  36 000e 4F93      		push r20
  37               	.LCFI4:
  38               		.cfi_def_cfa_offset 7
  39               		.cfi_offset 20, -6
  40 0010 5F93      		push r21
  41               	.LCFI5:
  42               		.cfi_def_cfa_offset 8
  43               		.cfi_offset 21, -7
  44 0012 6F93      		push r22
  45               	.LCFI6:
  46               		.cfi_def_cfa_offset 9
  47               		.cfi_offset 22, -8
  48 0014 7F93      		push r23
  49               	.LCFI7:
  50               		.cfi_def_cfa_offset 10
  51               		.cfi_offset 23, -9
  52 0016 8F93      		push r24
  53               	.LCFI8:
  54               		.cfi_def_cfa_offset 11
  55               		.cfi_offset 24, -10
  56 0018 9F93      		push r25
  57               	.LCFI9:
  58               		.cfi_def_cfa_offset 12
  59               		.cfi_offset 25, -11
  60 001a AF93      		push r26
  61               	.LCFI10:
  62               		.cfi_def_cfa_offset 13
  63               		.cfi_offset 26, -12
  64 001c BF93      		push r27
  65               	.LCFI11:
  66               		.cfi_def_cfa_offset 14
  67               		.cfi_offset 27, -13
  68 001e EF93      		push r30
  69               	.LCFI12:
  70               		.cfi_def_cfa_offset 15
  71               		.cfi_offset 30, -14
  72 0020 FF93      		push r31
  73               	.LCFI13:
  74               		.cfi_def_cfa_offset 16
  75               		.cfi_offset 31, -15
  76 0022 CF93      		push r28
  77               	.LCFI14:
  78               		.cfi_def_cfa_offset 17
  79               		.cfi_offset 28, -16
  80 0024 DF93      		push r29
  81               	.LCFI15:
  82               		.cfi_def_cfa_offset 18
  83               		.cfi_offset 29, -17
  84 0026 1F92      		push __zero_reg__
  85               	.LCFI16:
  86               		.cfi_def_cfa_offset 19
  87 0028 CDB7      		in r28,__SP_L__
  88 002a DEB7      		in r29,__SP_H__
  89               	.LCFI17:
  90               		.cfi_def_cfa_register 28
  91               	/* prologue: Signal */
  92               	/* frame size = 1 */
  93               	/* stack size = 18 */
  94               	.L__stack_usage = 18
  46:main.c        ****     volatile uint8_t status;   
  47:main.c        ****     
  48:main.c        **** 	// Read wl_module status 
  49:main.c        **** 	wl_module_CSN_lo;                               // Pull down chip select
  95               		.loc 1 49 0
  96 002c 2A98      		cbi 0x5,2
  50:main.c        **** 	status = spi_fast_shift(NOP);					// Read status register
  97               		.loc 1 50 0
  98 002e 8FEF      		ldi r24,lo8(-1)
  99 0030 00D0      		rcall spi_fast_shift
 100               	.LVL0:
 101 0032 8983      		std Y+1,r24
  51:main.c        **** 	wl_module_CSN_hi;                               // Pull up chip select
 102               		.loc 1 51 0
 103 0034 2A9A      		sbi 0x5,2
  52:main.c        **** 	
  53:main.c        **** 	switch(status & 0x70)
 104               		.loc 1 53 0
 105 0036 8981      		ldd r24,Y+1
 106 0038 8077      		andi r24,lo8(112)
 107 003a 8032      		cpi r24,lo8(32)
 108 003c 01F0      		breq .L4
 109 003e 8036      		cpi r24,lo8(96)
 110 0040 01F0      		breq .L4
 111 0042 8031      		cpi r24,lo8(16)
 112 0044 01F4      		brne .L2
  54:main.c        **** 	{
  55:main.c        **** 		case (1 << TX_DS):		
  56:main.c        **** 			PTX = 0;	
  57:main.c        **** 		break;
  58:main.c        **** 		
  59:main.c        **** 		case (1 << MAX_RT):
  60:main.c        **** 			wl_module_CSN_lo;                               // Pull down chip select
 113               		.loc 1 60 0
 114 0046 2A98      		cbi 0x5,2
  61:main.c        **** 			spi_fast_shift(FLUSH_TX);						// Flush TX-FIFO
 115               		.loc 1 61 0
 116 0048 81EE      		ldi r24,lo8(-31)
 117 004a 00D0      		rcall spi_fast_shift
 118               	.LVL1:
  62:main.c        **** 			wl_module_CSN_hi;  
 119               		.loc 1 62 0
 120 004c 2A9A      		sbi 0x5,2
 121               	.L4:
  63:main.c        **** 			PTX = 0;					
  64:main.c        **** 		break;
  65:main.c        **** 		
  66:main.c        **** 		case (1 << RX_DR):
  67:main.c        **** 			//wl_module_get_data(rxBuf);
  68:main.c        **** 			//bufferWrite(&wirelessRxBuf, rxBuf);
  69:main.c        **** 
  70:main.c        **** 		break;
  71:main.c        **** 		
  72:main.c        **** 		case ((1 << RX_DR) | (1 << TX_DS)):
  73:main.c        **** 			//wl_module_get_data(rxBuf);
  74:main.c        **** 			//bufferWrite(&wirelessRxBuf, rxBuf);
  75:main.c        **** 			PTX = 0;
 122               		.loc 1 75 0
 123 004e 1092 0000 		sts PTX,__zero_reg__
 124               	.L2:
  76:main.c        **** 		break;	
  77:main.c        **** 	}
  78:main.c        **** 		
  79:main.c        **** 	if (status & (1<<TX_FULL))							//TX_FIFO Full <-- this is not an IRQ
 125               		.loc 1 79 0
 126 0052 8981      		ldd r24,Y+1
 127 0054 80FF      		sbrs r24,0
 128 0056 00C0      		rjmp .L6
  80:main.c        **** 	{
  81:main.c        **** 		wl_module_CSN_lo;  
 129               		.loc 1 81 0
 130 0058 2A98      		cbi 0x5,2
  82:main.c        **** 		spi_fast_shift(FLUSH_TX);
 131               		.loc 1 82 0
 132 005a 81EE      		ldi r24,lo8(-31)
 133 005c 00D0      		rcall spi_fast_shift
 134               	.LVL2:
  83:main.c        **** 		wl_module_CSN_hi;  
 135               		.loc 1 83 0
 136 005e 2A9A      		sbi 0x5,2
  84:main.c        **** 		PTX = 0;
 137               		.loc 1 84 0
 138 0060 1092 0000 		sts PTX,__zero_reg__
 139               	.L6:
  85:main.c        **** 	}
  86:main.c        **** 		
  87:main.c        **** 	wl_module_config_register(STATUS, status & 0x70);	
 140               		.loc 1 87 0
 141 0064 6981      		ldd r22,Y+1
 142 0066 6077      		andi r22,lo8(112)
 143 0068 87E0      		ldi r24,lo8(7)
 144 006a 00D0      		rcall wl_module_config_register
 145               	.LVL3:
 146               	/* epilogue start */
  88:main.c        **** }
 147               		.loc 1 88 0
 148 006c 0F90      		pop __tmp_reg__
 149 006e DF91      		pop r29
 150 0070 CF91      		pop r28
 151 0072 FF91      		pop r31
 152 0074 EF91      		pop r30
 153 0076 BF91      		pop r27
 154 0078 AF91      		pop r26
 155 007a 9F91      		pop r25
 156 007c 8F91      		pop r24
 157 007e 7F91      		pop r23
 158 0080 6F91      		pop r22
 159 0082 5F91      		pop r21
 160 0084 4F91      		pop r20
 161 0086 3F91      		pop r19
 162 0088 2F91      		pop r18
 163 008a 0F90      		pop r0
 164 008c 0FBE      		out __SREG__,r0
 165 008e 0F90      		pop r0
 166 0090 1F90      		pop r1
 167 0092 1895      		reti
 168               		.cfi_endproc
 169               	.LFE6:
 171               	.global	__vector_17
 173               	__vector_17:
 174               	.LFB7:
  89:main.c        **** 
  90:main.c        **** ISR(SPI_STC_vect)
  91:main.c        **** {
 175               		.loc 1 91 0
 176               		.cfi_startproc
 177 0094 1F92      		push r1
 178               	.LCFI18:
 179               		.cfi_def_cfa_offset 3
 180               		.cfi_offset 1, -2
 181 0096 0F92      		push r0
 182               	.LCFI19:
 183               		.cfi_def_cfa_offset 4
 184               		.cfi_offset 0, -3
 185 0098 0FB6      		in r0,__SREG__
 186 009a 0F92      		push r0
 187 009c 1124      		clr __zero_reg__
 188               	/* prologue: Signal */
 189               	/* frame size = 0 */
 190               	/* stack size = 3 */
 191               	.L__stack_usage = 3
 192               	/* epilogue start */
  92:main.c        **** }
 193               		.loc 1 92 0
 194 009e 0F90      		pop r0
 195 00a0 0FBE      		out __SREG__,r0
 196 00a2 0F90      		pop r0
 197 00a4 1F90      		pop r1
 198 00a6 1895      		reti
 199               		.cfi_endproc
 200               	.LFE7:
 202               	.global	__vector_11
 204               	__vector_11:
 205               	.LFB8:
  93:main.c        **** 
  94:main.c        **** ISR(TIMER1_COMPA_vect)
  95:main.c        **** {
 206               		.loc 1 95 0
 207               		.cfi_startproc
 208 00a8 1F92      		push r1
 209               	.LCFI20:
 210               		.cfi_def_cfa_offset 3
 211               		.cfi_offset 1, -2
 212 00aa 0F92      		push r0
 213               	.LCFI21:
 214               		.cfi_def_cfa_offset 4
 215               		.cfi_offset 0, -3
 216 00ac 0FB6      		in r0,__SREG__
 217 00ae 0F92      		push r0
 218 00b0 1124      		clr __zero_reg__
 219 00b2 2F93      		push r18
 220               	.LCFI22:
 221               		.cfi_def_cfa_offset 5
 222               		.cfi_offset 18, -4
 223 00b4 3F93      		push r19
 224               	.LCFI23:
 225               		.cfi_def_cfa_offset 6
 226               		.cfi_offset 19, -5
 227 00b6 4F93      		push r20
 228               	.LCFI24:
 229               		.cfi_def_cfa_offset 7
 230               		.cfi_offset 20, -6
 231 00b8 5F93      		push r21
 232               	.LCFI25:
 233               		.cfi_def_cfa_offset 8
 234               		.cfi_offset 21, -7
 235 00ba 6F93      		push r22
 236               	.LCFI26:
 237               		.cfi_def_cfa_offset 9
 238               		.cfi_offset 22, -8
 239 00bc 7F93      		push r23
 240               	.LCFI27:
 241               		.cfi_def_cfa_offset 10
 242               		.cfi_offset 23, -9
 243 00be 8F93      		push r24
 244               	.LCFI28:
 245               		.cfi_def_cfa_offset 11
 246               		.cfi_offset 24, -10
 247 00c0 9F93      		push r25
 248               	.LCFI29:
 249               		.cfi_def_cfa_offset 12
 250               		.cfi_offset 25, -11
 251 00c2 AF93      		push r26
 252               	.LCFI30:
 253               		.cfi_def_cfa_offset 13
 254               		.cfi_offset 26, -12
 255 00c4 BF93      		push r27
 256               	.LCFI31:
 257               		.cfi_def_cfa_offset 14
 258               		.cfi_offset 27, -13
 259 00c6 EF93      		push r30
 260               	.LCFI32:
 261               		.cfi_def_cfa_offset 15
 262               		.cfi_offset 30, -14
 263 00c8 FF93      		push r31
 264               	.LCFI33:
 265               		.cfi_def_cfa_offset 16
 266               		.cfi_offset 31, -15
 267               	/* prologue: Signal */
 268               	/* frame size = 0 */
 269               	/* stack size = 15 */
 270               	.L__stack_usage = 15
  96:main.c        **** 	event_push(EVENT_timer_tick);
 271               		.loc 1 96 0
 272 00ca 81E0      		ldi r24,lo8(1)
 273 00cc 00D0      		rcall event_push
 274               	.LVL4:
 275               	/* epilogue start */
  97:main.c        **** }
 276               		.loc 1 97 0
 277 00ce FF91      		pop r31
 278 00d0 EF91      		pop r30
 279 00d2 BF91      		pop r27
 280 00d4 AF91      		pop r26
 281 00d6 9F91      		pop r25
 282 00d8 8F91      		pop r24
 283 00da 7F91      		pop r23
 284 00dc 6F91      		pop r22
 285 00de 5F91      		pop r21
 286 00e0 4F91      		pop r20
 287 00e2 3F91      		pop r19
 288 00e4 2F91      		pop r18
 289 00e6 0F90      		pop r0
 290 00e8 0FBE      		out __SREG__,r0
 291 00ea 0F90      		pop r0
 292 00ec 1F90      		pop r1
 293 00ee 1895      		reti
 294               		.cfi_endproc
 295               	.LFE8:
 297               		.section	.rodata
 298               	.LC0:
 299 0000 15        		.byte	21
 300 0001 72        		.byte	114
 301 0002 22        		.byte	34
 302 0003 02        		.byte	2
 303 0004 00        		.byte	0
 304 0005 72        		.byte	114
 305 0006 22        		.byte	34
 306 0007 02        		.byte	2
 307 0008 00        		.byte	0
 308 0009 80        		.byte	-128
 309 000a 0B        		.byte	11
 310 000b 00        		.byte	0
 311 000c 62        		.byte	98
 312 000d 09        		.byte	9
 313 000e 04        		.byte	4
 314 000f 97        		.byte	-105
 315 0010 00        		.byte	0
 316 0011 00        		.byte	0
 317 0012 00        		.byte	0
 318 0013 00        		.byte	0
 319 0014 00        		.byte	0
 320 0015 00        		.byte	0
 321 0016 00        		.byte	0
 322 0017 00        		.byte	0
 323 0018 F2        		.byte	-14
 324 0019 3D        		.byte	61
 325 001a A9        		.byte	-87
 326               		.section	.text.startup,"ax",@progbits
 327               	.global	main
 329               	main:
 330               	.LFB9:
  98:main.c        **** 
  99:main.c        **** int main(void)
 100:main.c        **** {	
 331               		.loc 1 100 0
 332               		.cfi_startproc
 333 0000 CF93      		push r28
 334               	.LCFI34:
 335               		.cfi_def_cfa_offset 3
 336               		.cfi_offset 28, -2
 337 0002 DF93      		push r29
 338               	.LCFI35:
 339               		.cfi_def_cfa_offset 4
 340               		.cfi_offset 29, -3
 341 0004 CDB7      		in r28,__SP_L__
 342 0006 DEB7      		in r29,__SP_H__
 343               	.LCFI36:
 344               		.cfi_def_cfa_register 28
 345 0008 6E97      		sbiw r28,30
 346               	.LCFI37:
 347               		.cfi_def_cfa_offset 34
 348 000a 0FB6      		in __tmp_reg__,__SREG__
 349 000c F894      		cli
 350 000e DEBF      		out __SP_H__,r29
 351 0010 0FBE      		out __SREG__,__tmp_reg__
 352 0012 CDBF      		out __SP_L__,r28
 353               	/* prologue: function */
 354               	/* frame size = 30 */
 355               	/* stack size = 32 */
 356               	.L__stack_usage = 32
 101:main.c        **** 	uint8_t buf[27] = {0x15,0x72,0x22,0x02,0x00,0x72,0x22,0x02,0x00,0x80,0x0B,0x00,0x62,0x09,0x04,0x97
 357               		.loc 1 101 0
 358 0014 8BE1      		ldi r24,lo8(27)
 359 0016 E0E0      		ldi r30,lo8(.LC0)
 360 0018 F0E0      		ldi r31,hi8(.LC0)
 361 001a DE01      		movw r26,r28
 362 001c 1196      		adiw r26,1
 363               		0:
 364 001e 0190      		ld r0,Z+
 365 0020 0D92      		st X+,r0
 366 0022 8A95      		dec r24
 367 0024 01F4      		brne 0b
 102:main.c        **** 	volatile uint8_t crc8_c = 0;
 368               		.loc 1 102 0
 369 0026 1E8E      		std Y+30,__zero_reg__
 103:main.c        **** 	volatile uint16_t crc16_c = 0;
 370               		.loc 1 103 0
 371 0028 1D8E      		std Y+29,__zero_reg__
 372 002a 1C8E      		std Y+28,__zero_reg__
 104:main.c        **** 
 105:main.c        **** 	hardware_init();
 373               		.loc 1 105 0
 374 002c 00D0      		rcall hardware_init
 375               	.LVL5:
 106:main.c        **** 	wl_module_init();
 376               		.loc 1 106 0
 377 002e 00D0      		rcall wl_module_init
 378               	.LVL6:
 107:main.c        **** 	state_machine__init();
 379               		.loc 1 107 0
 380 0030 00D0      		rcall state_machine__init
 381               	.LVL7:
 382               	.LBB8:
 383               	.LBB9:
 384               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 385               		.loc 2 187 0
 386 0032 2FE9      		ldi r18,lo8(99999)
 387 0034 86E8      		ldi r24,hi8(99999)
 388 0036 91E0      		ldi r25,hlo8(99999)
 389 0038 2150      	1:	subi r18,1
 390 003a 8040      		sbci r24,0
 391 003c 9040      		sbci r25,0
 392 003e 01F4      		brne 1b
 393 0040 00C0      		rjmp .
 394 0042 0000      		nop
 395               	.LVL8:
 396               	.LBE9:
 397               	.LBE8:
 108:main.c        **** 		
 109:main.c        **** 	_delay_ms(50);
 110:main.c        **** 	
 111:main.c        **** 	sei();
 398               		.loc 1 111 0
 399               	/* #APP */
 400               	 ;  111 "main.c" 1
 401 0044 7894      		sei
 402               	 ;  0 "" 2
 403               	/* #NOAPP */
 404               	.L14:
 405               	.LVL9:
 406               	.LBB10:
 407               	.LBB11:
 408               		.loc 2 187 0 discriminator 1
 409 0046 2FE3      		ldi r18,lo8(999999)
 410 0048 82E4      		ldi r24,hi8(999999)
 411 004a 9FE0      		ldi r25,hlo8(999999)
 412 004c 2150      	1:	subi r18,1
 413 004e 8040      		sbci r24,0
 414 0050 9040      		sbci r25,0
 415 0052 01F4      		brne 1b
 416 0054 00C0      		rjmp .
 417 0056 0000      		nop
 418               	.LVL10:
 419               	.LBE11:
 420               	.LBE10:
 112:main.c        **** 
 113:main.c        **** 	while(1)
 114:main.c        ****     {
 115:main.c        **** 		_delay_ms(500);
 116:main.c        **** 		crc8_c = crc8_calc(buf,26);
 421               		.loc 1 116 0 discriminator 1
 422 0058 6AE1      		ldi r22,lo8(26)
 423 005a CE01      		movw r24,r28
 424 005c 0196      		adiw r24,1
 425 005e 00D0      		rcall crc8_calc
 426               	.LVL11:
 427 0060 8E8F      		std Y+30,r24
 117:main.c        **** 		crc16_c = crc16_calc(buf+10,14);
 428               		.loc 1 117 0 discriminator 1
 429 0062 6EE0      		ldi r22,lo8(14)
 430 0064 CE01      		movw r24,r28
 431 0066 0B96      		adiw r24,11
 432 0068 00D0      		rcall crc16_calc
 433               	.LVL12:
 434 006a 9D8F      		std Y+29,r25
 435 006c 8C8F      		std Y+28,r24
 436               	.LVL13:
 437               	.LBB12:
 438               	.LBB13:
 439               		.loc 2 187 0 discriminator 1
 440 006e 2FE3      		ldi r18,lo8(999999)
 441 0070 82E4      		ldi r24,hi8(999999)
 442 0072 9FE0      		ldi r25,hlo8(999999)
 443 0074 2150      	1:	subi r18,1
 444 0076 8040      		sbci r24,0
 445 0078 9040      		sbci r25,0
 446 007a 01F4      		brne 1b
 447 007c 00C0      		rjmp .
 448 007e 0000      		nop
 449               	.LVL14:
 450               	.LBE13:
 451               	.LBE12:
 118:main.c        **** 		_delay_ms(500);
 119:main.c        **** 		uart_putc(crc8_c);
 452               		.loc 1 119 0 discriminator 1
 453 0080 8E8D      		ldd r24,Y+30
 454 0082 00D0      		rcall uart_putc
 455               	.LVL15:
 120:main.c        **** 		uart_putc(' ');
 456               		.loc 1 120 0 discriminator 1
 457 0084 80E2      		ldi r24,lo8(32)
 458 0086 00D0      		rcall uart_putc
 459               	.LVL16:
 121:main.c        **** 		uart_putc( ((uint8_t*) &crc16_c)[0]);
 460               		.loc 1 121 0 discriminator 1
 461 0088 8C8D      		ldd r24,Y+28
 462 008a 00D0      		rcall uart_putc
 463               	.LVL17:
 122:main.c        **** 		uart_putc( ((uint8_t*) &crc16_c)[1]);
 464               		.loc 1 122 0 discriminator 1
 465 008c 8D8D      		ldd r24,Y+29
 466 008e 00D0      		rcall uart_putc
 467               	.LVL18:
 123:main.c        **** 		uart_putc('\r');
 468               		.loc 1 123 0 discriminator 1
 469 0090 8DE0      		ldi r24,lo8(13)
 470 0092 00D0      		rcall uart_putc
 471               	.LVL19:
 124:main.c        **** 		uart_putc('\n');
 472               		.loc 1 124 0 discriminator 1
 473 0094 8AE0      		ldi r24,lo8(10)
 474 0096 00D0      		rcall uart_putc
 475               	.LVL20:
 476 0098 00C0      		rjmp .L14
 477               		.cfi_endproc
 478               	.LFE9:
 480               		.comm	main_state,1,1
 481               		.comm	PTX,1,1
 482               		.text
 483               	.Letext0:
 484               		.file 3 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 485               		.file 4 "statemachine.h"
 486               		.file 5 "spi.h"
 487               		.file 6 "wl_module.h"
 488               		.file 7 "hardware.h"
 489               		.file 8 "crc.h"
 490               		.file 9 "uart.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\mcmai\AppData\Local\Temp\ccKjIQbA.s:2      *ABS*:0000003e __SP_H__
C:\Users\mcmai\AppData\Local\Temp\ccKjIQbA.s:3      *ABS*:0000003d __SP_L__
C:\Users\mcmai\AppData\Local\Temp\ccKjIQbA.s:4      *ABS*:0000003f __SREG__
C:\Users\mcmai\AppData\Local\Temp\ccKjIQbA.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\mcmai\AppData\Local\Temp\ccKjIQbA.s:6      *ABS*:00000001 __zero_reg__
C:\Users\mcmai\AppData\Local\Temp\ccKjIQbA.s:12     .text:00000000 __vector_1
                            *COM*:00000001 PTX
C:\Users\mcmai\AppData\Local\Temp\ccKjIQbA.s:173    .text:00000094 __vector_17
C:\Users\mcmai\AppData\Local\Temp\ccKjIQbA.s:204    .text:000000a8 __vector_11
C:\Users\mcmai\AppData\Local\Temp\ccKjIQbA.s:329    .text.startup:00000000 main
                            *COM*:00000001 main_state

UNDEFINED SYMBOLS
spi_fast_shift
wl_module_config_register
event_push
hardware_init
wl_module_init
state_machine__init
crc8_calc
crc16_calc
uart_putc
__do_copy_data
__do_clear_bss
