   1               		.file	"wl_module.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	wl_module_init
  12               	wl_module_init:
  13               	.LFB6:
  14               		.file 1 "wl_module.c"
   1:wl_module.c   **** /*
   2:wl_module.c   **** 	Copyright (c) 2011 by Ernst Buchmann 
   3:wl_module.c   **** 	
   4:wl_module.c   **** 	Code based on the work of Stefan Engelke and Brennan Ball
   5:wl_module.c   **** 	
   6:wl_module.c   ****     Permission is hereby granted, free of charge, to any person 
   7:wl_module.c   ****     obtaining a copy of this software and associated documentation 
   8:wl_module.c   ****     files (the "Software"), to deal in the Software without 
   9:wl_module.c   ****     restriction, including without limitation the rights to use, copy, 
  10:wl_module.c   ****     modify, merge, publish, distribute, sublicense, and/or sell copies 
  11:wl_module.c   ****     of the Software, and to permit persons to whom the Software is 
  12:wl_module.c   ****     furnished to do so, subject to the following conditions:
  13:wl_module.c   **** 
  14:wl_module.c   ****     The above copyright notice and this permission notice shall be 
  15:wl_module.c   ****     included in all copies or substantial portions of the Software.
  16:wl_module.c   **** 
  17:wl_module.c   ****     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
  18:wl_module.c   ****     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
  19:wl_module.c   ****     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
  20:wl_module.c   ****     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
  21:wl_module.c   ****     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
  22:wl_module.c   ****     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
  23:wl_module.c   ****     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
  24:wl_module.c   ****     DEALINGS IN THE SOFTWARE.
  25:wl_module.c   **** 
  26:wl_module.c   ****     
  27:wl_module.c   **** */
  28:wl_module.c   **** 
  29:wl_module.c   **** #include "wl_module.h"
  30:wl_module.c   **** #include "nRF24L01.h"
  31:wl_module.c   **** #include "spi.h"
  32:wl_module.c   **** #include <avr/io.h>
  33:wl_module.c   **** #include <avr/interrupt.h>
  34:wl_module.c   **** #include <util/delay.h>
  35:wl_module.c   **** 
  36:wl_module.c   **** // Defines for setting the wl_module registers for transmitting or receiving mode
  37:wl_module.c   **** #define TX_POWERUP wl_module_config_register(CONFIG, wl_module_CONFIG | ( (1<<PWR_UP) | (0<<PRIM_RX
  38:wl_module.c   **** #define RX_POWERUP wl_module_config_register(CONFIG, wl_module_CONFIG | ( (1<<PWR_UP) | (1<<PRIM_RX
  39:wl_module.c   **** 
  40:wl_module.c   **** 
  41:wl_module.c   **** // Flag which denotes transmitting mode
  42:wl_module.c   **** extern volatile uint8_t PTX;
  43:wl_module.c   **** 
  44:wl_module.c   **** void wl_module_init() 
  45:wl_module.c   **** // Initializes pins and interrupt to communicate with the wl_module
  46:wl_module.c   **** // Should be called in the early initializing phase at startup.
  47:wl_module.c   **** {
  15               		.loc 1 47 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  48:wl_module.c   ****     // Define CSN and CE as Output and set them to default
  49:wl_module.c   ****     DDRB |= (1 << CSN);
  21               		.loc 1 49 0
  22 0000 229A      		sbi 0x4,2
  50:wl_module.c   **** 	DDRB |= (1 << CE);
  23               		.loc 1 50 0
  24 0002 209A      		sbi 0x4,0
  51:wl_module.c   ****     wl_module_CE_lo;
  25               		.loc 1 51 0
  26 0004 2898      		cbi 0x5,0
  52:wl_module.c   ****     wl_module_CSN_hi;
  27               		.loc 1 52 0
  28 0006 2A9A      		sbi 0x5,2
  53:wl_module.c   **** 
  54:wl_module.c   ****     // Initialize spi module
  55:wl_module.c   ****     spi_init();
  29               		.loc 1 55 0
  30 0008 00C0      		rjmp spi_init
  31               	.LVL0:
  32               		.cfi_endproc
  33               	.LFE6:
  35               	.global	wl_module_get_rx_pipe_from_status
  37               	wl_module_get_rx_pipe_from_status:
  38               	.LFB18:
  56:wl_module.c   **** }
  57:wl_module.c   **** 
  58:wl_module.c   **** 
  59:wl_module.c   **** void wl_module_config() 
  60:wl_module.c   **** // Sets the important registers in the wl-module and powers the module
  61:wl_module.c   **** // in receiving mode
  62:wl_module.c   **** {
  63:wl_module.c   ****     // Set RF channel
  64:wl_module.c   ****     wl_module_config_register(RF_CH,wl_module_CH);
  65:wl_module.c   **** 	// Set data speed & Output Power configured in wl_module.h
  66:wl_module.c   **** 	wl_module_config_register(RF_SETUP,wl_module_RF_SETUP);
  67:wl_module.c   **** 	// Set length of incoming payload 
  68:wl_module.c   ****     wl_module_config_register(RX_PW_P0, wl_module_PAYLOAD);
  69:wl_module.c   **** 	
  70:wl_module.c   ****     // Start receiver 
  71:wl_module.c   ****     PTX = 0;        // Start in receiving mode
  72:wl_module.c   ****     RX_POWERUP;     // Power up in receiving mode
  73:wl_module.c   ****     wl_module_CE_hi;     // Listening for pakets
  74:wl_module.c   **** }
  75:wl_module.c   **** 
  76:wl_module.c   **** extern void wl_module_rx_config() 
  77:wl_module.c   **** // Sets the important registers in the wl-module and powers the module
  78:wl_module.c   **** // in receiving mode
  79:wl_module.c   **** {
  80:wl_module.c   **** 	uint8_t data[5];
  81:wl_module.c   ****     // Set RF channel
  82:wl_module.c   ****     wl_module_config_register(RF_CH,wl_module_CH);
  83:wl_module.c   **** 	// Set data speed & Output Power configured in wl_module.h
  84:wl_module.c   **** 	wl_module_config_register(RF_SETUP,wl_module_RF_SETUP);
  85:wl_module.c   **** 	//Enable all RX Data-Pipes
  86:wl_module.c   **** 	wl_module_config_register(EN_RXADDR, EN_RXADDR_ERX_ALL);
  87:wl_module.c   **** 	//Set RX_Address Pipe 0
  88:wl_module.c   **** 	data[0]= data[1]= data[2]= data[3]= data[4]= RX_ADDR_P0_B0_DEFAULT_VAL;
  89:wl_module.c   **** 	wl_module_set_rx_addr(data, 5, 0);
  90:wl_module.c   **** 	//Set RX_Address Pipe 1
  91:wl_module.c   **** 	data[0]= data[1]= data[2]= data[3]= data[4]= RX_ADDR_P1_B0_DEFAULT_VAL;
  92:wl_module.c   **** 	wl_module_set_rx_addr(data, 5, 1);
  93:wl_module.c   **** 	//Set RX_Address Pipe 2-5
  94:wl_module.c   **** 	data[0]=RX_ADDR_P2_DEFAULT_VAL;
  95:wl_module.c   **** 	wl_module_set_rx_addr(data, 1, 2);
  96:wl_module.c   **** 	data[0]=RX_ADDR_P3_DEFAULT_VAL;
  97:wl_module.c   **** 	wl_module_set_rx_addr(data, 1, 3);
  98:wl_module.c   **** 	data[0]=RX_ADDR_P4_DEFAULT_VAL;
  99:wl_module.c   **** 	wl_module_set_rx_addr(data, 1, 4);
 100:wl_module.c   **** 	data[0]=RX_ADDR_P5_DEFAULT_VAL;
 101:wl_module.c   **** 	wl_module_set_rx_addr(data, 1, 5);
 102:wl_module.c   ****     // Set length of incoming payload 
 103:wl_module.c   ****     wl_module_config_register(RX_PW_P0, wl_module_PAYLOAD);
 104:wl_module.c   **** 	wl_module_config_register(RX_PW_P1, wl_module_PAYLOAD);
 105:wl_module.c   **** 	wl_module_config_register(RX_PW_P2, wl_module_PAYLOAD);
 106:wl_module.c   **** 	wl_module_config_register(RX_PW_P3, wl_module_PAYLOAD);
 107:wl_module.c   **** 	wl_module_config_register(RX_PW_P4, wl_module_PAYLOAD);
 108:wl_module.c   **** 	wl_module_config_register(RX_PW_P5, wl_module_PAYLOAD);
 109:wl_module.c   **** 	
 110:wl_module.c   **** 	
 111:wl_module.c   ****     // Start receiver 
 112:wl_module.c   ****     PTX = 0;        // Start in receiving mode
 113:wl_module.c   ****     RX_POWERUP;     // Power up in receiving mode
 114:wl_module.c   ****     wl_module_CE_hi;     // Listening for pakets
 115:wl_module.c   **** }
 116:wl_module.c   **** 
 117:wl_module.c   **** // Sets the wl-module as one of the six sender. Define for every sender a unique Number (wl_module_
 118:wl_module.c   **** // when you call this Function.
 119:wl_module.c   **** //  Each TX will get a TX-Address corresponding to the RX-Device.
 120:wl_module.c   **** // RX_Address_Pipe_0 must be the same as the TX-Address
 121:wl_module.c   **** extern void wl_module_tx_config(uint8_t tx_nr) 
 122:wl_module.c   **** {
 123:wl_module.c   **** 	uint8_t tx_addr[5];
 124:wl_module.c   **** 	
 125:wl_module.c   ****     // Set RF channel
 126:wl_module.c   ****     wl_module_config_register(RF_CH,wl_module_CH);
 127:wl_module.c   **** 	// Set data speed & Output Power configured in wl_module.h
 128:wl_module.c   **** 	wl_module_config_register(RF_SETUP,wl_module_RF_SETUP);
 129:wl_module.c   **** 	//Config the CONFIG Register (Mask IRQ, CRC, etc)
 130:wl_module.c   **** 	wl_module_config_register(CONFIG, wl_module_CONFIG);
 131:wl_module.c   ****     // Set length of incoming payload 
 132:wl_module.c   ****     //wl_module_config_register(RX_PW_P0, wl_module_PAYLOAD);
 133:wl_module.c   **** 	
 134:wl_module.c   **** 	wl_module_config_register(SETUP_RETR,(SETUP_RETR_ARD_500 | SETUP_RETR_ARC_10));
 135:wl_module.c   **** 	
 136:wl_module.c   **** 	//set the TX address for the pipe with the same number as the iteration
 137:wl_module.c   **** 			switch(tx_nr)			
 138:wl_module.c   **** 			{
 139:wl_module.c   **** 				case 0: //setup TX address as default RX address for pipe 0 (E7:E7:E7:E7:E7)
 140:wl_module.c   **** 					tx_addr[0] = tx_addr[1] = tx_addr[2] = tx_addr[3] = tx_addr[4] = RX_ADDR_P0_B0_DEFAULT_VAL;
 141:wl_module.c   **** 					wl_module_set_TADDR(tx_addr);
 142:wl_module.c   **** 					wl_module_set_RADDR(tx_addr);
 143:wl_module.c   **** 					break;
 144:wl_module.c   **** 				case 1: //setup TX address as default RX address for pipe 1 (C2:C2:C2:C2:C2)
 145:wl_module.c   **** 					tx_addr[0] = tx_addr[1] = tx_addr[2] = tx_addr[3] = tx_addr[4] = RX_ADDR_P1_B0_DEFAULT_VAL;
 146:wl_module.c   **** 					wl_module_set_TADDR(tx_addr);
 147:wl_module.c   **** 					wl_module_set_RADDR(tx_addr);
 148:wl_module.c   **** 					break;
 149:wl_module.c   **** 				case 2: //setup TX address as default RX address for pipe 2 (C2:C2:C2:C2:C3)
 150:wl_module.c   **** 					tx_addr[1] = tx_addr[2] = tx_addr[3] = tx_addr[4] = RX_ADDR_P1_B0_DEFAULT_VAL;
 151:wl_module.c   **** 					tx_addr[0] = RX_ADDR_P2_DEFAULT_VAL;
 152:wl_module.c   **** 					wl_module_set_TADDR(tx_addr);
 153:wl_module.c   **** 					wl_module_set_RADDR(tx_addr);
 154:wl_module.c   **** 					break;
 155:wl_module.c   **** 				case 3: //setup TX address as default RX address for pipe 3 (C2:C2:C2:C2:C4)
 156:wl_module.c   **** 					tx_addr[1] = tx_addr[2] = tx_addr[3] = tx_addr[4] = RX_ADDR_P1_B0_DEFAULT_VAL;
 157:wl_module.c   **** 					tx_addr[0] = RX_ADDR_P3_DEFAULT_VAL;
 158:wl_module.c   **** 					wl_module_set_TADDR(tx_addr);
 159:wl_module.c   **** 					wl_module_set_RADDR(tx_addr);
 160:wl_module.c   **** 					break;
 161:wl_module.c   **** 				case 4: //setup TX address as default RX address for pipe 4 (C2:C2:C2:C2:C5)
 162:wl_module.c   **** 					tx_addr[1] = tx_addr[2] = tx_addr[3] = tx_addr[4] = RX_ADDR_P1_B0_DEFAULT_VAL;
 163:wl_module.c   **** 					tx_addr[0] = RX_ADDR_P4_DEFAULT_VAL;
 164:wl_module.c   **** 					wl_module_set_TADDR(tx_addr);
 165:wl_module.c   **** 					wl_module_set_RADDR(tx_addr);
 166:wl_module.c   **** 					break;
 167:wl_module.c   **** 				case 5: //setup TX address as default RX address for pipe 5 (C2:C2:C2:C2:C6)
 168:wl_module.c   **** 					tx_addr[1] = tx_addr[2] = tx_addr[3] = tx_addr[4] = RX_ADDR_P1_B0_DEFAULT_VAL;
 169:wl_module.c   **** 					tx_addr[0] = RX_ADDR_P5_DEFAULT_VAL;
 170:wl_module.c   **** 					wl_module_set_TADDR(tx_addr);
 171:wl_module.c   **** 					wl_module_set_RADDR(tx_addr);
 172:wl_module.c   **** 					break;
 173:wl_module.c   **** 			}
 174:wl_module.c   **** 	
 175:wl_module.c   **** 	//PTX =1;
 176:wl_module.c   **** 	//TX_POWERUP;
 177:wl_module.c   **** 	
 178:wl_module.c   ****     // Start receiver 
 179:wl_module.c   ****     PTX = 0;        // Start in receiving mode
 180:wl_module.c   ****     RX_POWERUP;     // Power up in receiving mode
 181:wl_module.c   ****     wl_module_CE_hi;     // Listening for pakets	
 182:wl_module.c   **** }
 183:wl_module.c   **** 
 184:wl_module.c   **** //sets the TX address in the TX_ADDR register
 185:wl_module.c   **** //unsigned char * address is the actual address to be used.  It should be sized
 186:wl_module.c   **** //	according to the tx_addr length specified to the nrf24l01.
 187:wl_module.c   **** //unsigned int len is the length of the address.  Its value should be specified
 188:wl_module.c   **** //	according to the tx_addr length specified to the nrf24l01.
 189:wl_module.c   **** extern void wl_module_set_tx_addr(uint8_t * address, uint8_t len)
 190:wl_module.c   **** {		
 191:wl_module.c   **** 	wl_module_write_register(TX_ADDR, address, len);
 192:wl_module.c   **** }
 193:wl_module.c   **** 
 194:wl_module.c   **** //sets up the 24L01 as a transmitter
 195:wl_module.c   **** //this function takes the existing contents of the CONFIG register and simply
 196:wl_module.c   **** //  clears the PRIM_RX bit in the CONFIG register.
 197:wl_module.c   **** //note: if the read value of the CONFIG register already has the PRIM_RX bit cleared, this 
 198:wl_module.c   **** //  function exits in order to not make an unecessary register write.
 199:wl_module.c   **** extern void wl_module_set_as_tx()
 200:wl_module.c   **** {
 201:wl_module.c   **** 	unsigned char config;
 202:wl_module.c   **** 	
 203:wl_module.c   **** 	wl_module_read_register(CONFIG, &config, 1);
 204:wl_module.c   **** 	
 205:wl_module.c   **** 	if((config & CONFIG_PRIM_RX) == 0)
 206:wl_module.c   **** 		return;
 207:wl_module.c   **** 	
 208:wl_module.c   **** 	config &= (~CONFIG_PRIM_RX);
 209:wl_module.c   **** 	
 210:wl_module.c   **** 	wl_module_write_register(CONFIG, &config, 1);
 211:wl_module.c   **** 
 212:wl_module.c   **** 	wl_module_CE_lo;
 213:wl_module.c   **** }
 214:wl_module.c   **** 
 215:wl_module.c   **** //powers down the 24L01
 216:wl_module.c   **** //this function takes the existing contents of the CONFIG register and simply
 217:wl_module.c   **** //  clears the PWR_UP bit in the CONFIG register.
 218:wl_module.c   **** //note: if the read value of the CONFIG register already has the PWR_UP bit cleared, this 
 219:wl_module.c   **** //  function exits in order to not make an unecessary register write.
 220:wl_module.c   **** extern void wl_module_power_down()
 221:wl_module.c   **** {
 222:wl_module.c   **** 	unsigned char config;
 223:wl_module.c   **** 	
 224:wl_module.c   **** 	wl_module_read_register(CONFIG, &config, 1);
 225:wl_module.c   **** 	
 226:wl_module.c   **** 	if((config & CONFIG_PWR_UP) == 0)
 227:wl_module.c   **** 		return;
 228:wl_module.c   **** 	
 229:wl_module.c   **** 	config &= (~CONFIG_PWR_UP);
 230:wl_module.c   **** 	
 231:wl_module.c   **** 	wl_module_write_register(CONFIG, &config, 1);
 232:wl_module.c   **** 
 233:wl_module.c   **** 	wl_module_CE_lo;
 234:wl_module.c   **** }
 235:wl_module.c   **** 
 236:wl_module.c   **** //sets the RX address in the RX_ADDR register that is offset by rxpipenum
 237:wl_module.c   **** //unsigned char * address is the actual address to be used.  It should be sized
 238:wl_module.c   **** //	according to the rx_addr length that is being filled.
 239:wl_module.c   **** //unsigned int len is the length of the address.  Its value should be specified
 240:wl_module.c   **** //	according to the rx_addr length specified to the nrf24l01.
 241:wl_module.c   **** //unsigned char rxpipenum is the pipe number (zero to five) whose address is being
 242:wl_module.c   **** //	specified.  If an invalid address (greater than five) is supplied, the function
 243:wl_module.c   **** //  does nothing.
 244:wl_module.c   **** extern void wl_module_set_rx_addr(uint8_t * address, uint8_t len, uint8_t rxpipenum)
 245:wl_module.c   **** {	
 246:wl_module.c   **** 	if(rxpipenum > 5)
 247:wl_module.c   **** 		return;
 248:wl_module.c   **** 		
 249:wl_module.c   **** 	wl_module_write_register(RX_ADDR_P0 + rxpipenum, address, len);
 250:wl_module.c   **** }
 251:wl_module.c   **** 
 252:wl_module.c   **** extern void wl_module_get_rx_addr(uint8_t *data, uint8_t rxpipenum, uint8_t len)
 253:wl_module.c   **** {
 254:wl_module.c   **** 	
 255:wl_module.c   **** 	if((rxpipenum > 5))
 256:wl_module.c   **** 		return;
 257:wl_module.c   **** 		
 258:wl_module.c   **** 	wl_module_read_register(RX_ADDR_P0 + rxpipenum, data, len);
 259:wl_module.c   **** 	
 260:wl_module.c   **** 	
 261:wl_module.c   **** }
 262:wl_module.c   **** 
 263:wl_module.c   **** //sets the RX payload width on the pipe offset by rxpipenum
 264:wl_module.c   **** //unsigned char payloadwidth is the length of the payload for the pipe referenced in
 265:wl_module.c   **** //  rxpipenum.  It must be less than or equal to 32.  If an invalid payload width is
 266:wl_module.c   **** //  specified, the function does nothing.
 267:wl_module.c   **** //unsigned char rxpipenum is the pipe number (zero to five) whose address is being
 268:wl_module.c   **** //	specified.  If an invalid address (greater than five) is supplied, the function
 269:wl_module.c   **** //  does nothing.
 270:wl_module.c   **** extern void wl_module_set_rx_pw(unsigned char payloadwidth, unsigned char rxpipenum)
 271:wl_module.c   **** {
 272:wl_module.c   **** 	if((rxpipenum > 5) || (payloadwidth > 32))
 273:wl_module.c   **** 		return;
 274:wl_module.c   **** 		
 275:wl_module.c   **** 	wl_module_write_register(RX_PW_P0 + rxpipenum, &payloadwidth, 1);
 276:wl_module.c   **** }
 277:wl_module.c   **** 
 278:wl_module.c   **** //gets the RX payload width on the pipe offset by rxpipenum
 279:wl_module.c   **** //unsigned char rxpipenum is the pipe number (zero to five) whose address is being
 280:wl_module.c   **** //	specified.  If an invalid address (greater than five) is supplied, the function
 281:wl_module.c   **** //  does nothing.
 282:wl_module.c   **** extern uint8_t wl_module_get_rx_pw(uint8_t rxpipenum)
 283:wl_module.c   **** {
 284:wl_module.c   **** 	unsigned char data;
 285:wl_module.c   **** 	
 286:wl_module.c   **** 	if((rxpipenum > 5))
 287:wl_module.c   **** 		return 0;
 288:wl_module.c   **** 		
 289:wl_module.c   **** 	wl_module_read_register(RX_PW_P0 + rxpipenum, &data, 1);
 290:wl_module.c   **** 	
 291:wl_module.c   **** 	return data;
 292:wl_module.c   **** }
 293:wl_module.c   **** 
 294:wl_module.c   **** //returns the current pipe in the 24L01's STATUS register
 295:wl_module.c   **** extern uint8_t wl_module_get_rx_pipe()
 296:wl_module.c   **** {
 297:wl_module.c   **** 	return wl_module_get_rx_pipe_from_status(wl_module_get_status());
 298:wl_module.c   **** }
 299:wl_module.c   **** 
 300:wl_module.c   **** extern uint8_t wl_module_get_rx_pipe_from_status(uint8_t status)
 301:wl_module.c   **** {
  39               		.loc 1 301 0
  40               		.cfi_startproc
  41               	.LVL1:
  42               	/* prologue: function */
  43               	/* frame size = 0 */
  44               	/* stack size = 0 */
  45               	.L__stack_usage = 0
 302:wl_module.c   **** 	return ((status & 0xE) >> 1);
  46               		.loc 1 302 0
  47 000a 8E70      		andi r24,lo8(14)
  48               	.LVL2:
 303:wl_module.c   **** }
  49               		.loc 1 303 0
  50 000c 8695      		lsr r24
  51 000e 0895      		ret
  52               		.cfi_endproc
  53               	.LFE18:
  55               	.global	wl_module_data_ready
  57               	wl_module_data_ready:
  58               	.LFB21:
 304:wl_module.c   **** 
 305:wl_module.c   **** void wl_module_set_RADDR(uint8_t * adr) 
 306:wl_module.c   **** // Sets the receiving address
 307:wl_module.c   **** {
 308:wl_module.c   ****     wl_module_CE_lo;
 309:wl_module.c   ****     wl_module_write_register(RX_ADDR_P0,adr,5);
 310:wl_module.c   ****     wl_module_CE_hi;
 311:wl_module.c   **** }
 312:wl_module.c   **** 
 313:wl_module.c   **** void wl_module_set_TADDR(uint8_t * adr)
 314:wl_module.c   **** // Sets the transmitting address
 315:wl_module.c   **** {
 316:wl_module.c   ****     wl_module_write_register(TX_ADDR, adr,5);
 317:wl_module.c   **** }
 318:wl_module.c   **** 
 319:wl_module.c   **** 
 320:wl_module.c   **** 
 321:wl_module.c   **** extern uint8_t wl_module_data_ready() 
 322:wl_module.c   **** // Checks if data is available for reading
 323:wl_module.c   **** {
  59               		.loc 1 323 0
  60               		.cfi_startproc
  61               	/* prologue: function */
  62               	/* frame size = 0 */
  63               	/* stack size = 0 */
  64               	.L__stack_usage = 0
 324:wl_module.c   ****     if (PTX) return 0;
  65               		.loc 1 324 0
  66 0010 8091 0000 		lds r24,PTX
  67 0014 8111      		cpse r24,__zero_reg__
  68 0016 00C0      		rjmp .L5
 325:wl_module.c   ****     uint8_t status;
 326:wl_module.c   ****     // Read wl_module status 
 327:wl_module.c   ****     wl_module_CSN_lo;                                // Pull down chip select
  69               		.loc 1 327 0
  70 0018 2A98      		cbi 0x5,2
 328:wl_module.c   ****     status = spi_fast_shift(NOP);               // Read status register
  71               		.loc 1 328 0
  72 001a 8FEF      		ldi r24,lo8(-1)
  73 001c 00D0      		rcall spi_fast_shift
  74               	.LVL3:
 329:wl_module.c   ****     wl_module_CSN_hi;                                // Pull up chip select
  75               		.loc 1 329 0
  76 001e 2A9A      		sbi 0x5,2
 330:wl_module.c   ****     return status & (1<<RX_DR);
  77               		.loc 1 330 0
  78 0020 8074      		andi r24,lo8(64)
  79               	.LVL4:
  80 0022 0895      		ret
  81               	.L5:
 324:wl_module.c   ****     uint8_t status;
  82               		.loc 1 324 0
  83 0024 80E0      		ldi r24,0
 331:wl_module.c   **** }
  84               		.loc 1 331 0
  85 0026 0895      		ret
  86               		.cfi_endproc
  87               	.LFE21:
  89               	.global	wl_module_get_one_byte
  91               	wl_module_get_one_byte:
  92               	.LFB30:
 332:wl_module.c   **** 
 333:wl_module.c   **** //returns true if TX_EMPTY bit in FIFO_STATUS register is set, false otherwise
 334:wl_module.c   **** extern uint8_t wl_module_fifo_tx_empty()
 335:wl_module.c   **** {
 336:wl_module.c   **** 	uint8_t data;
 337:wl_module.c   **** 	
 338:wl_module.c   **** 	wl_module_read_register(FIFO_STATUS, &data, 1);
 339:wl_module.c   **** 	
 340:wl_module.c   **** 	
 341:wl_module.c   **** 	return (data & FIFO_STATUS_TX_EMPTY);
 342:wl_module.c   **** }
 343:wl_module.c   **** 
 344:wl_module.c   **** //returns true if RX_EMPTY bit in FIFO_STATUS register is set, false otherwise
 345:wl_module.c   **** extern uint8_t wl_module_fifo_rx_empty()
 346:wl_module.c   **** {
 347:wl_module.c   **** 	uint8_t data;
 348:wl_module.c   **** 	
 349:wl_module.c   **** 	wl_module_read_register(FIFO_STATUS, &data, 1);
 350:wl_module.c   **** 	
 351:wl_module.c   **** 	return (data & FIFO_STATUS_RX_EMPTY);
 352:wl_module.c   **** }
 353:wl_module.c   **** 
 354:wl_module.c   **** //returns the current RF channel in RF_CH register
 355:wl_module.c   **** extern uint8_t wl_module_get_rf_ch()
 356:wl_module.c   **** {
 357:wl_module.c   **** 	uint8_t data;
 358:wl_module.c   **** 	
 359:wl_module.c   **** 	wl_module_read_register(RF_CH, &data, 1);
 360:wl_module.c   **** 	
 361:wl_module.c   **** 	return data;
 362:wl_module.c   **** }
 363:wl_module.c   **** 
 364:wl_module.c   **** //returns the current RF_SETUP Register
 365:wl_module.c   **** extern uint8_t wl_module_get_rf_setup()
 366:wl_module.c   **** {
 367:wl_module.c   **** 	uint8_t data;
 368:wl_module.c   **** 	
 369:wl_module.c   **** 	wl_module_read_register(RF_SETUP, &data, 1);
 370:wl_module.c   **** 	
 371:wl_module.c   **** 	return data;
 372:wl_module.c   **** }
 373:wl_module.c   **** 
 374:wl_module.c   **** //returns the current PLOS_CNT value in OBSERVE_TX register
 375:wl_module.c   **** extern uint8_t wl_module_get_plos_cnt()
 376:wl_module.c   **** {
 377:wl_module.c   **** 	uint8_t data;
 378:wl_module.c   **** 	
 379:wl_module.c   **** 	wl_module_read_register(OBSERVE_TX, &data, 1);
 380:wl_module.c   **** 	
 381:wl_module.c   **** 	return ((data & OBSERVE_TX_PLOS_CNT) >> 4);
 382:wl_module.c   **** }
 383:wl_module.c   **** 
 384:wl_module.c   **** //returns the current ARC_CNT value in OBSERVE_TX register
 385:wl_module.c   **** extern uint8_t wl_module_get_arc_cnt()
 386:wl_module.c   **** {
 387:wl_module.c   **** 	uint8_t data;
 388:wl_module.c   **** 	
 389:wl_module.c   **** 	wl_module_read_register(OBSERVE_TX, &data, 1);
 390:wl_module.c   **** 	
 391:wl_module.c   **** 	return (data & OBSERVE_TX_ARC_CNT);
 392:wl_module.c   **** }
 393:wl_module.c   **** 
 394:wl_module.c   **** //return the value of the status register
 395:wl_module.c   **** extern uint8_t wl_module_get_status()
 396:wl_module.c   **** {
 397:wl_module.c   **** 	return wl_module_get_one_byte(NOP);
 398:wl_module.c   **** }
 399:wl_module.c   **** 
 400:wl_module.c   **** extern uint8_t wl_module_get_rx_pipe_reading_status()
 401:wl_module.c   **** {
 402:wl_module.c   **** 	uint8_t pipe;
 403:wl_module.c   **** 	pipe = wl_module_get_one_byte(NOP);
 404:wl_module.c   **** 	return ((pipe & 0x0E) >> 1);
 405:wl_module.c   **** }
 406:wl_module.c   **** 
 407:wl_module.c   **** extern uint8_t wl_module_get_one_byte(uint8_t command)
 408:wl_module.c   **** {
  93               		.loc 1 408 0
  94               		.cfi_startproc
  95               	.LVL5:
  96               	/* prologue: function */
  97               	/* frame size = 0 */
  98               	/* stack size = 0 */
  99               	.L__stack_usage = 0
 409:wl_module.c   **** uint8_t status;
 410:wl_module.c   **** 
 411:wl_module.c   **** wl_module_CSN_lo;
 100               		.loc 1 411 0
 101 0028 2A98      		cbi 0x5,2
 412:wl_module.c   **** status = spi_fast_shift(command);
 102               		.loc 1 412 0
 103 002a 00D0      		rcall spi_fast_shift
 104               	.LVL6:
 413:wl_module.c   **** wl_module_CSN_hi;
 105               		.loc 1 413 0
 106 002c 2A9A      		sbi 0x5,2
 414:wl_module.c   **** 
 415:wl_module.c   **** return status;
 416:wl_module.c   **** 
 417:wl_module.c   **** }
 107               		.loc 1 417 0
 108 002e 0895      		ret
 109               		.cfi_endproc
 110               	.LFE30:
 112               	.global	wl_module_get_status
 114               	wl_module_get_status:
 115               	.LFB28:
 396:wl_module.c   **** 	return wl_module_get_one_byte(NOP);
 116               		.loc 1 396 0
 117               		.cfi_startproc
 118               	/* prologue: function */
 119               	/* frame size = 0 */
 120               	/* stack size = 0 */
 121               	.L__stack_usage = 0
 397:wl_module.c   **** }
 122               		.loc 1 397 0
 123 0030 8FEF      		ldi r24,lo8(-1)
 124 0032 00C0      		rjmp wl_module_get_one_byte
 125               	.LVL7:
 126               		.cfi_endproc
 127               	.LFE28:
 129               	.global	wl_module_get_rx_pipe
 131               	wl_module_get_rx_pipe:
 132               	.LFB17:
 296:wl_module.c   **** 	return wl_module_get_rx_pipe_from_status(wl_module_get_status());
 133               		.loc 1 296 0
 134               		.cfi_startproc
 135               	/* prologue: function */
 136               	/* frame size = 0 */
 137               	/* stack size = 0 */
 138               	.L__stack_usage = 0
 297:wl_module.c   **** }
 139               		.loc 1 297 0
 140 0034 00D0      		rcall wl_module_get_status
 141               	.LVL8:
 142 0036 8E70      		andi r24,lo8(14)
 298:wl_module.c   **** 
 143               		.loc 1 298 0
 144 0038 8695      		lsr r24
 145 003a 0895      		ret
 146               		.cfi_endproc
 147               	.LFE17:
 149               	.global	wl_module_get_rx_pipe_reading_status
 151               	wl_module_get_rx_pipe_reading_status:
 152               	.LFB29:
 401:wl_module.c   **** 	uint8_t pipe;
 153               		.loc 1 401 0
 154               		.cfi_startproc
 155               	/* prologue: function */
 156               	/* frame size = 0 */
 157               	/* stack size = 0 */
 158               	.L__stack_usage = 0
 403:wl_module.c   **** 	return ((pipe & 0x0E) >> 1);
 159               		.loc 1 403 0
 160 003c 8FEF      		ldi r24,lo8(-1)
 161 003e 00D0      		rcall wl_module_get_one_byte
 162               	.LVL9:
 404:wl_module.c   **** }
 163               		.loc 1 404 0
 164 0040 8E70      		andi r24,lo8(14)
 165               	.LVL10:
 405:wl_module.c   **** 
 166               		.loc 1 405 0
 167 0042 8695      		lsr r24
 168 0044 0895      		ret
 169               		.cfi_endproc
 170               	.LFE29:
 172               	.global	wl_module_get_data
 174               	wl_module_get_data:
 175               	.LFB31:
 418:wl_module.c   **** 
 419:wl_module.c   **** extern uint8_t wl_module_get_data(uint8_t * data) 
 420:wl_module.c   **** // Reads wl_module_PAYLOAD bytes into data array
 421:wl_module.c   **** {
 176               		.loc 1 421 0
 177               		.cfi_startproc
 178               	.LVL11:
 179 0046 1F93      		push r17
 180               	.LCFI0:
 181               		.cfi_def_cfa_offset 3
 182               		.cfi_offset 17, -2
 183 0048 CF93      		push r28
 184               	.LCFI1:
 185               		.cfi_def_cfa_offset 4
 186               		.cfi_offset 28, -3
 187 004a DF93      		push r29
 188               	.LCFI2:
 189               		.cfi_def_cfa_offset 5
 190               		.cfi_offset 29, -4
 191               	/* prologue: function */
 192               	/* frame size = 0 */
 193               	/* stack size = 3 */
 194               	.L__stack_usage = 3
 195 004c EC01      		movw r28,r24
 422:wl_module.c   **** 	uint8_t status;
 423:wl_module.c   ****     wl_module_CSN_lo;                               // Pull down chip select
 196               		.loc 1 423 0
 197 004e 2A98      		cbi 0x5,2
 424:wl_module.c   ****     status = spi_fast_shift( R_RX_PAYLOAD );            // Send cmd to read rx payload
 198               		.loc 1 424 0
 199 0050 81E6      		ldi r24,lo8(97)
 200               	.LVL12:
 201 0052 00D0      		rcall spi_fast_shift
 202               	.LVL13:
 203 0054 182F      		mov r17,r24
 204               	.LVL14:
 425:wl_module.c   ****     spi_transfer_sync(data,data,wl_module_PAYLOAD); // Read payload
 205               		.loc 1 425 0
 206 0056 40E2      		ldi r20,lo8(32)
 207 0058 BE01      		movw r22,r28
 208 005a CE01      		movw r24,r28
 209 005c 00D0      		rcall spi_transfer_sync
 210               	.LVL15:
 426:wl_module.c   ****     wl_module_CSN_hi;                               // Pull up chip select
 211               		.loc 1 426 0
 212 005e 2A9A      		sbi 0x5,2
 427:wl_module.c   ****     //wl_module_config_register(STATUS,(1<<RX_DR));   // Reset status register
 428:wl_module.c   **** 	return status;
 429:wl_module.c   **** }
 213               		.loc 1 429 0
 214 0060 812F      		mov r24,r17
 215               	/* epilogue start */
 216 0062 DF91      		pop r29
 217 0064 CF91      		pop r28
 218               	.LVL16:
 219 0066 1F91      		pop r17
 220               	.LVL17:
 221 0068 0895      		ret
 222               		.cfi_endproc
 223               	.LFE31:
 225               	.global	wl_module_config_register
 227               	wl_module_config_register:
 228               	.LFB32:
 430:wl_module.c   **** 
 431:wl_module.c   **** 
 432:wl_module.c   **** extern uint8_t wl_module_config_register(uint8_t reg, uint8_t value)
 433:wl_module.c   **** // Clocks only one byte into the given wl-module register
 434:wl_module.c   **** {
 229               		.loc 1 434 0
 230               		.cfi_startproc
 231               	.LVL18:
 232 006a CF93      		push r28
 233               	.LCFI3:
 234               		.cfi_def_cfa_offset 3
 235               		.cfi_offset 28, -2
 236 006c DF93      		push r29
 237               	.LCFI4:
 238               		.cfi_def_cfa_offset 4
 239               		.cfi_offset 29, -3
 240               	/* prologue: function */
 241               	/* frame size = 0 */
 242               	/* stack size = 2 */
 243               	.L__stack_usage = 2
 244 006e D62F      		mov r29,r22
 435:wl_module.c   **** 	uint8_t status;
 436:wl_module.c   **** 	
 437:wl_module.c   ****     wl_module_CSN_lo;
 245               		.loc 1 437 0
 246 0070 2A98      		cbi 0x5,2
 438:wl_module.c   ****     status = spi_fast_shift(W_REGISTER | (REGISTER_MASK & reg));
 247               		.loc 1 438 0
 248 0072 8F71      		andi r24,lo8(31)
 249               	.LVL19:
 250 0074 8062      		ori r24,lo8(32)
 251 0076 00D0      		rcall spi_fast_shift
 252               	.LVL20:
 253 0078 C82F      		mov r28,r24
 254               	.LVL21:
 439:wl_module.c   ****     spi_fast_shift(value);
 255               		.loc 1 439 0
 256 007a 8D2F      		mov r24,r29
 257               	.LVL22:
 258 007c 00D0      		rcall spi_fast_shift
 259               	.LVL23:
 440:wl_module.c   ****     wl_module_CSN_hi;
 260               		.loc 1 440 0
 261 007e 2A9A      		sbi 0x5,2
 441:wl_module.c   **** 	
 442:wl_module.c   **** 	return status;
 443:wl_module.c   **** }
 262               		.loc 1 443 0
 263 0080 8C2F      		mov r24,r28
 264               	/* epilogue start */
 265 0082 DF91      		pop r29
 266               	.LVL24:
 267 0084 CF91      		pop r28
 268               	.LVL25:
 269 0086 0895      		ret
 270               		.cfi_endproc
 271               	.LFE32:
 273               	.global	wl_module_config
 275               	wl_module_config:
 276               	.LFB7:
  62:wl_module.c   ****     // Set RF channel
 277               		.loc 1 62 0
 278               		.cfi_startproc
 279               	/* prologue: function */
 280               	/* frame size = 0 */
 281               	/* stack size = 0 */
 282               	.L__stack_usage = 0
  64:wl_module.c   **** 	// Set data speed & Output Power configured in wl_module.h
 283               		.loc 1 64 0
 284 0088 63E0      		ldi r22,lo8(3)
 285 008a 85E0      		ldi r24,lo8(5)
 286 008c 00D0      		rcall wl_module_config_register
 287               	.LVL26:
  66:wl_module.c   **** 	// Set length of incoming payload 
 288               		.loc 1 66 0
 289 008e 66E0      		ldi r22,lo8(6)
 290 0090 86E0      		ldi r24,lo8(6)
 291 0092 00D0      		rcall wl_module_config_register
 292               	.LVL27:
  68:wl_module.c   **** 	
 293               		.loc 1 68 0
 294 0094 60E2      		ldi r22,lo8(32)
 295 0096 81E1      		ldi r24,lo8(17)
 296 0098 00D0      		rcall wl_module_config_register
 297               	.LVL28:
  71:wl_module.c   ****     RX_POWERUP;     // Power up in receiving mode
 298               		.loc 1 71 0
 299 009a 1092 0000 		sts PTX,__zero_reg__
  72:wl_module.c   ****     wl_module_CE_hi;     // Listening for pakets
 300               		.loc 1 72 0
 301 009e 6FE0      		ldi r22,lo8(15)
 302 00a0 80E0      		ldi r24,0
 303 00a2 00D0      		rcall wl_module_config_register
 304               	.LVL29:
  73:wl_module.c   **** }
 305               		.loc 1 73 0
 306 00a4 289A      		sbi 0x5,0
 307 00a6 0895      		ret
 308               		.cfi_endproc
 309               	.LFE7:
 311               	.global	wl_module_read_register
 313               	wl_module_read_register:
 314               	.LFB33:
 444:wl_module.c   **** 
 445:wl_module.c   **** /*
 446:wl_module.c   **** void wl_module_config_register(uint8_t reg, uint8_t value)
 447:wl_module.c   **** // Clocks only one byte into the given wl-module register
 448:wl_module.c   **** {
 449:wl_module.c   ****     wl_module_CSN_lo;
 450:wl_module.c   ****     spi_fast_shift(W_REGISTER | (REGISTER_MASK & reg));
 451:wl_module.c   ****     spi_fast_shift(value);
 452:wl_module.c   ****     wl_module_CSN_hi;
 453:wl_module.c   **** }*/
 454:wl_module.c   **** 
 455:wl_module.c   **** void wl_module_read_register(uint8_t reg, uint8_t * value, uint8_t len)
 456:wl_module.c   **** // Reads an array of bytes from the given start position in the wl-module registers.
 457:wl_module.c   **** {
 315               		.loc 1 457 0
 316               		.cfi_startproc
 317               	.LVL30:
 318 00a8 1F93      		push r17
 319               	.LCFI5:
 320               		.cfi_def_cfa_offset 3
 321               		.cfi_offset 17, -2
 322 00aa CF93      		push r28
 323               	.LCFI6:
 324               		.cfi_def_cfa_offset 4
 325               		.cfi_offset 28, -3
 326 00ac DF93      		push r29
 327               	.LCFI7:
 328               		.cfi_def_cfa_offset 5
 329               		.cfi_offset 29, -4
 330               	/* prologue: function */
 331               	/* frame size = 0 */
 332               	/* stack size = 3 */
 333               	.L__stack_usage = 3
 334 00ae EB01      		movw r28,r22
 335 00b0 142F      		mov r17,r20
 458:wl_module.c   ****     wl_module_CSN_lo;
 336               		.loc 1 458 0
 337 00b2 2A98      		cbi 0x5,2
 459:wl_module.c   ****     spi_fast_shift(R_REGISTER | (REGISTER_MASK & reg));
 338               		.loc 1 459 0
 339 00b4 8F71      		andi r24,lo8(31)
 340               	.LVL31:
 341 00b6 00D0      		rcall spi_fast_shift
 342               	.LVL32:
 460:wl_module.c   ****     spi_transfer_sync(value,value,len);
 343               		.loc 1 460 0
 344 00b8 412F      		mov r20,r17
 345 00ba BE01      		movw r22,r28
 346 00bc CE01      		movw r24,r28
 347 00be 00D0      		rcall spi_transfer_sync
 348               	.LVL33:
 461:wl_module.c   ****     wl_module_CSN_hi;
 349               		.loc 1 461 0
 350 00c0 2A9A      		sbi 0x5,2
 351               	/* epilogue start */
 462:wl_module.c   **** }
 352               		.loc 1 462 0
 353 00c2 DF91      		pop r29
 354 00c4 CF91      		pop r28
 355               	.LVL34:
 356 00c6 1F91      		pop r17
 357               	.LVL35:
 358 00c8 0895      		ret
 359               		.cfi_endproc
 360               	.LFE33:
 362               	.global	wl_module_get_rx_addr
 364               	wl_module_get_rx_addr:
 365               	.LFB14:
 253:wl_module.c   **** 	
 366               		.loc 1 253 0
 367               		.cfi_startproc
 368               	.LVL36:
 369               	/* prologue: function */
 370               	/* frame size = 0 */
 371               	/* stack size = 0 */
 372               	.L__stack_usage = 0
 373 00ca 9C01      		movw r18,r24
 374 00cc 862F      		mov r24,r22
 375               	.LVL37:
 255:wl_module.c   **** 		return;
 376               		.loc 1 255 0
 377 00ce 6630      		cpi r22,lo8(6)
 378 00d0 00F4      		brsh .L15
 258:wl_module.c   **** 	
 379               		.loc 1 258 0
 380 00d2 B901      		movw r22,r18
 381               	.LVL38:
 382 00d4 865F      		subi r24,lo8(-(10))
 383               	.LVL39:
 384 00d6 00C0      		rjmp wl_module_read_register
 385               	.LVL40:
 386               	.L15:
 387 00d8 0895      		ret
 388               		.cfi_endproc
 389               	.LFE14:
 391               	.global	wl_module_get_rx_pw
 393               	wl_module_get_rx_pw:
 394               	.LFB16:
 283:wl_module.c   **** 	unsigned char data;
 395               		.loc 1 283 0
 396               		.cfi_startproc
 397               	.LVL41:
 398 00da CF93      		push r28
 399               	.LCFI8:
 400               		.cfi_def_cfa_offset 3
 401               		.cfi_offset 28, -2
 402 00dc DF93      		push r29
 403               	.LCFI9:
 404               		.cfi_def_cfa_offset 4
 405               		.cfi_offset 29, -3
 406 00de 1F92      		push __zero_reg__
 407               	.LCFI10:
 408               		.cfi_def_cfa_offset 5
 409 00e0 CDB7      		in r28,__SP_L__
 410 00e2 DEB7      		in r29,__SP_H__
 411               	.LCFI11:
 412               		.cfi_def_cfa_register 28
 413               	/* prologue: function */
 414               	/* frame size = 1 */
 415               	/* stack size = 3 */
 416               	.L__stack_usage = 3
 286:wl_module.c   **** 		return 0;
 417               		.loc 1 286 0
 418 00e4 8630      		cpi r24,lo8(6)
 419 00e6 00F4      		brsh .L19
 289:wl_module.c   **** 	
 420               		.loc 1 289 0
 421 00e8 41E0      		ldi r20,lo8(1)
 422 00ea BE01      		movw r22,r28
 423 00ec 6F5F      		subi r22,-1
 424 00ee 7F4F      		sbci r23,-1
 425 00f0 8F5E      		subi r24,lo8(-(17))
 426               	.LVL42:
 427 00f2 00D0      		rcall wl_module_read_register
 428               	.LVL43:
 291:wl_module.c   **** }
 429               		.loc 1 291 0
 430 00f4 8981      		ldd r24,Y+1
 431 00f6 00C0      		rjmp .L18
 432               	.LVL44:
 433               	.L19:
 287:wl_module.c   **** 		
 434               		.loc 1 287 0
 435 00f8 80E0      		ldi r24,0
 436               	.LVL45:
 437               	.L18:
 438               	/* epilogue start */
 292:wl_module.c   **** 
 439               		.loc 1 292 0
 440 00fa 0F90      		pop __tmp_reg__
 441 00fc DF91      		pop r29
 442 00fe CF91      		pop r28
 443 0100 0895      		ret
 444               		.cfi_endproc
 445               	.LFE16:
 447               	.global	wl_module_fifo_tx_empty
 449               	wl_module_fifo_tx_empty:
 450               	.LFB22:
 335:wl_module.c   **** 	uint8_t data;
 451               		.loc 1 335 0
 452               		.cfi_startproc
 453 0102 CF93      		push r28
 454               	.LCFI12:
 455               		.cfi_def_cfa_offset 3
 456               		.cfi_offset 28, -2
 457 0104 DF93      		push r29
 458               	.LCFI13:
 459               		.cfi_def_cfa_offset 4
 460               		.cfi_offset 29, -3
 461 0106 1F92      		push __zero_reg__
 462               	.LCFI14:
 463               		.cfi_def_cfa_offset 5
 464 0108 CDB7      		in r28,__SP_L__
 465 010a DEB7      		in r29,__SP_H__
 466               	.LCFI15:
 467               		.cfi_def_cfa_register 28
 468               	/* prologue: function */
 469               	/* frame size = 1 */
 470               	/* stack size = 3 */
 471               	.L__stack_usage = 3
 338:wl_module.c   **** 	
 472               		.loc 1 338 0
 473 010c 41E0      		ldi r20,lo8(1)
 474 010e BE01      		movw r22,r28
 475 0110 6F5F      		subi r22,-1
 476 0112 7F4F      		sbci r23,-1
 477 0114 87E1      		ldi r24,lo8(23)
 478 0116 00D0      		rcall wl_module_read_register
 479               	.LVL46:
 341:wl_module.c   **** }
 480               		.loc 1 341 0
 481 0118 8981      		ldd r24,Y+1
 342:wl_module.c   **** 
 482               		.loc 1 342 0
 483 011a 8071      		andi r24,lo8(16)
 484               	/* epilogue start */
 485 011c 0F90      		pop __tmp_reg__
 486 011e DF91      		pop r29
 487 0120 CF91      		pop r28
 488 0122 0895      		ret
 489               		.cfi_endproc
 490               	.LFE22:
 492               	.global	wl_module_fifo_rx_empty
 494               	wl_module_fifo_rx_empty:
 495               	.LFB23:
 346:wl_module.c   **** 	uint8_t data;
 496               		.loc 1 346 0
 497               		.cfi_startproc
 498 0124 CF93      		push r28
 499               	.LCFI16:
 500               		.cfi_def_cfa_offset 3
 501               		.cfi_offset 28, -2
 502 0126 DF93      		push r29
 503               	.LCFI17:
 504               		.cfi_def_cfa_offset 4
 505               		.cfi_offset 29, -3
 506 0128 1F92      		push __zero_reg__
 507               	.LCFI18:
 508               		.cfi_def_cfa_offset 5
 509 012a CDB7      		in r28,__SP_L__
 510 012c DEB7      		in r29,__SP_H__
 511               	.LCFI19:
 512               		.cfi_def_cfa_register 28
 513               	/* prologue: function */
 514               	/* frame size = 1 */
 515               	/* stack size = 3 */
 516               	.L__stack_usage = 3
 349:wl_module.c   **** 	
 517               		.loc 1 349 0
 518 012e 41E0      		ldi r20,lo8(1)
 519 0130 BE01      		movw r22,r28
 520 0132 6F5F      		subi r22,-1
 521 0134 7F4F      		sbci r23,-1
 522 0136 87E1      		ldi r24,lo8(23)
 523 0138 00D0      		rcall wl_module_read_register
 524               	.LVL47:
 351:wl_module.c   **** }
 525               		.loc 1 351 0
 526 013a 8981      		ldd r24,Y+1
 352:wl_module.c   **** 
 527               		.loc 1 352 0
 528 013c 8170      		andi r24,lo8(1)
 529               	/* epilogue start */
 530 013e 0F90      		pop __tmp_reg__
 531 0140 DF91      		pop r29
 532 0142 CF91      		pop r28
 533 0144 0895      		ret
 534               		.cfi_endproc
 535               	.LFE23:
 537               	.global	wl_module_get_rf_ch
 539               	wl_module_get_rf_ch:
 540               	.LFB24:
 356:wl_module.c   **** 	uint8_t data;
 541               		.loc 1 356 0
 542               		.cfi_startproc
 543 0146 CF93      		push r28
 544               	.LCFI20:
 545               		.cfi_def_cfa_offset 3
 546               		.cfi_offset 28, -2
 547 0148 DF93      		push r29
 548               	.LCFI21:
 549               		.cfi_def_cfa_offset 4
 550               		.cfi_offset 29, -3
 551 014a 1F92      		push __zero_reg__
 552               	.LCFI22:
 553               		.cfi_def_cfa_offset 5
 554 014c CDB7      		in r28,__SP_L__
 555 014e DEB7      		in r29,__SP_H__
 556               	.LCFI23:
 557               		.cfi_def_cfa_register 28
 558               	/* prologue: function */
 559               	/* frame size = 1 */
 560               	/* stack size = 3 */
 561               	.L__stack_usage = 3
 359:wl_module.c   **** 	
 562               		.loc 1 359 0
 563 0150 41E0      		ldi r20,lo8(1)
 564 0152 BE01      		movw r22,r28
 565 0154 6F5F      		subi r22,-1
 566 0156 7F4F      		sbci r23,-1
 567 0158 85E0      		ldi r24,lo8(5)
 568 015a 00D0      		rcall wl_module_read_register
 569               	.LVL48:
 362:wl_module.c   **** 
 570               		.loc 1 362 0
 571 015c 8981      		ldd r24,Y+1
 572               	/* epilogue start */
 573 015e 0F90      		pop __tmp_reg__
 574 0160 DF91      		pop r29
 575 0162 CF91      		pop r28
 576 0164 0895      		ret
 577               		.cfi_endproc
 578               	.LFE24:
 580               	.global	wl_module_get_rf_setup
 582               	wl_module_get_rf_setup:
 583               	.LFB25:
 366:wl_module.c   **** 	uint8_t data;
 584               		.loc 1 366 0
 585               		.cfi_startproc
 586 0166 CF93      		push r28
 587               	.LCFI24:
 588               		.cfi_def_cfa_offset 3
 589               		.cfi_offset 28, -2
 590 0168 DF93      		push r29
 591               	.LCFI25:
 592               		.cfi_def_cfa_offset 4
 593               		.cfi_offset 29, -3
 594 016a 1F92      		push __zero_reg__
 595               	.LCFI26:
 596               		.cfi_def_cfa_offset 5
 597 016c CDB7      		in r28,__SP_L__
 598 016e DEB7      		in r29,__SP_H__
 599               	.LCFI27:
 600               		.cfi_def_cfa_register 28
 601               	/* prologue: function */
 602               	/* frame size = 1 */
 603               	/* stack size = 3 */
 604               	.L__stack_usage = 3
 369:wl_module.c   **** 	
 605               		.loc 1 369 0
 606 0170 41E0      		ldi r20,lo8(1)
 607 0172 BE01      		movw r22,r28
 608 0174 6F5F      		subi r22,-1
 609 0176 7F4F      		sbci r23,-1
 610 0178 86E0      		ldi r24,lo8(6)
 611 017a 00D0      		rcall wl_module_read_register
 612               	.LVL49:
 372:wl_module.c   **** 
 613               		.loc 1 372 0
 614 017c 8981      		ldd r24,Y+1
 615               	/* epilogue start */
 616 017e 0F90      		pop __tmp_reg__
 617 0180 DF91      		pop r29
 618 0182 CF91      		pop r28
 619 0184 0895      		ret
 620               		.cfi_endproc
 621               	.LFE25:
 623               	.global	wl_module_get_plos_cnt
 625               	wl_module_get_plos_cnt:
 626               	.LFB26:
 376:wl_module.c   **** 	uint8_t data;
 627               		.loc 1 376 0
 628               		.cfi_startproc
 629 0186 CF93      		push r28
 630               	.LCFI28:
 631               		.cfi_def_cfa_offset 3
 632               		.cfi_offset 28, -2
 633 0188 DF93      		push r29
 634               	.LCFI29:
 635               		.cfi_def_cfa_offset 4
 636               		.cfi_offset 29, -3
 637 018a 1F92      		push __zero_reg__
 638               	.LCFI30:
 639               		.cfi_def_cfa_offset 5
 640 018c CDB7      		in r28,__SP_L__
 641 018e DEB7      		in r29,__SP_H__
 642               	.LCFI31:
 643               		.cfi_def_cfa_register 28
 644               	/* prologue: function */
 645               	/* frame size = 1 */
 646               	/* stack size = 3 */
 647               	.L__stack_usage = 3
 379:wl_module.c   **** 	
 648               		.loc 1 379 0
 649 0190 41E0      		ldi r20,lo8(1)
 650 0192 BE01      		movw r22,r28
 651 0194 6F5F      		subi r22,-1
 652 0196 7F4F      		sbci r23,-1
 653 0198 88E0      		ldi r24,lo8(8)
 654 019a 00D0      		rcall wl_module_read_register
 655               	.LVL50:
 381:wl_module.c   **** }
 656               		.loc 1 381 0
 657 019c 8981      		ldd r24,Y+1
 382:wl_module.c   **** 
 658               		.loc 1 382 0
 659 019e 8295      		swap r24
 660 01a0 8F70      		andi r24,lo8(15)
 661               	/* epilogue start */
 662 01a2 0F90      		pop __tmp_reg__
 663 01a4 DF91      		pop r29
 664 01a6 CF91      		pop r28
 665 01a8 0895      		ret
 666               		.cfi_endproc
 667               	.LFE26:
 669               	.global	wl_module_get_arc_cnt
 671               	wl_module_get_arc_cnt:
 672               	.LFB27:
 386:wl_module.c   **** 	uint8_t data;
 673               		.loc 1 386 0
 674               		.cfi_startproc
 675 01aa CF93      		push r28
 676               	.LCFI32:
 677               		.cfi_def_cfa_offset 3
 678               		.cfi_offset 28, -2
 679 01ac DF93      		push r29
 680               	.LCFI33:
 681               		.cfi_def_cfa_offset 4
 682               		.cfi_offset 29, -3
 683 01ae 1F92      		push __zero_reg__
 684               	.LCFI34:
 685               		.cfi_def_cfa_offset 5
 686 01b0 CDB7      		in r28,__SP_L__
 687 01b2 DEB7      		in r29,__SP_H__
 688               	.LCFI35:
 689               		.cfi_def_cfa_register 28
 690               	/* prologue: function */
 691               	/* frame size = 1 */
 692               	/* stack size = 3 */
 693               	.L__stack_usage = 3
 389:wl_module.c   **** 	
 694               		.loc 1 389 0
 695 01b4 41E0      		ldi r20,lo8(1)
 696 01b6 BE01      		movw r22,r28
 697 01b8 6F5F      		subi r22,-1
 698 01ba 7F4F      		sbci r23,-1
 699 01bc 88E0      		ldi r24,lo8(8)
 700 01be 00D0      		rcall wl_module_read_register
 701               	.LVL51:
 391:wl_module.c   **** }
 702               		.loc 1 391 0
 703 01c0 8981      		ldd r24,Y+1
 392:wl_module.c   **** 
 704               		.loc 1 392 0
 705 01c2 8F70      		andi r24,lo8(15)
 706               	/* epilogue start */
 707 01c4 0F90      		pop __tmp_reg__
 708 01c6 DF91      		pop r29
 709 01c8 CF91      		pop r28
 710 01ca 0895      		ret
 711               		.cfi_endproc
 712               	.LFE27:
 714               	.global	wl_module_write_register
 716               	wl_module_write_register:
 717               	.LFB34:
 463:wl_module.c   **** 
 464:wl_module.c   **** void wl_module_write_register(uint8_t reg, uint8_t * value, uint8_t len) 
 465:wl_module.c   **** // Writes an array of bytes into inte the wl-module registers.
 466:wl_module.c   **** {
 718               		.loc 1 466 0
 719               		.cfi_startproc
 720               	.LVL52:
 721 01cc 1F93      		push r17
 722               	.LCFI36:
 723               		.cfi_def_cfa_offset 3
 724               		.cfi_offset 17, -2
 725 01ce CF93      		push r28
 726               	.LCFI37:
 727               		.cfi_def_cfa_offset 4
 728               		.cfi_offset 28, -3
 729 01d0 DF93      		push r29
 730               	.LCFI38:
 731               		.cfi_def_cfa_offset 5
 732               		.cfi_offset 29, -4
 733               	/* prologue: function */
 734               	/* frame size = 0 */
 735               	/* stack size = 3 */
 736               	.L__stack_usage = 3
 737 01d2 EB01      		movw r28,r22
 738 01d4 142F      		mov r17,r20
 467:wl_module.c   ****     wl_module_CSN_lo;
 739               		.loc 1 467 0
 740 01d6 2A98      		cbi 0x5,2
 468:wl_module.c   ****     spi_fast_shift(W_REGISTER | (REGISTER_MASK & reg));
 741               		.loc 1 468 0
 742 01d8 8F71      		andi r24,lo8(31)
 743               	.LVL53:
 744 01da 8062      		ori r24,lo8(32)
 745 01dc 00D0      		rcall spi_fast_shift
 746               	.LVL54:
 469:wl_module.c   ****     spi_transmit_sync(value,len);
 747               		.loc 1 469 0
 748 01de 612F      		mov r22,r17
 749 01e0 CE01      		movw r24,r28
 750 01e2 00D0      		rcall spi_transmit_sync
 751               	.LVL55:
 470:wl_module.c   ****     wl_module_CSN_hi;
 752               		.loc 1 470 0
 753 01e4 2A9A      		sbi 0x5,2
 754               	/* epilogue start */
 471:wl_module.c   **** }
 755               		.loc 1 471 0
 756 01e6 DF91      		pop r29
 757 01e8 CF91      		pop r28
 758               	.LVL56:
 759 01ea 1F91      		pop r17
 760               	.LVL57:
 761 01ec 0895      		ret
 762               		.cfi_endproc
 763               	.LFE34:
 765               	.global	wl_module_set_tx_addr
 767               	wl_module_set_tx_addr:
 768               	.LFB10:
 190:wl_module.c   **** 	wl_module_write_register(TX_ADDR, address, len);
 769               		.loc 1 190 0
 770               		.cfi_startproc
 771               	.LVL58:
 772               	/* prologue: function */
 773               	/* frame size = 0 */
 774               	/* stack size = 0 */
 775               	.L__stack_usage = 0
 776 01ee 462F      		mov r20,r22
 191:wl_module.c   **** }
 777               		.loc 1 191 0
 778 01f0 BC01      		movw r22,r24
 779               	.LVL59:
 780 01f2 80E1      		ldi r24,lo8(16)
 781               	.LVL60:
 782 01f4 00C0      		rjmp wl_module_write_register
 783               	.LVL61:
 784               		.cfi_endproc
 785               	.LFE10:
 787               	.global	wl_module_set_as_tx
 789               	wl_module_set_as_tx:
 790               	.LFB11:
 200:wl_module.c   **** 	unsigned char config;
 791               		.loc 1 200 0
 792               		.cfi_startproc
 793 01f6 CF93      		push r28
 794               	.LCFI39:
 795               		.cfi_def_cfa_offset 3
 796               		.cfi_offset 28, -2
 797 01f8 DF93      		push r29
 798               	.LCFI40:
 799               		.cfi_def_cfa_offset 4
 800               		.cfi_offset 29, -3
 801 01fa 1F92      		push __zero_reg__
 802               	.LCFI41:
 803               		.cfi_def_cfa_offset 5
 804 01fc CDB7      		in r28,__SP_L__
 805 01fe DEB7      		in r29,__SP_H__
 806               	.LCFI42:
 807               		.cfi_def_cfa_register 28
 808               	/* prologue: function */
 809               	/* frame size = 1 */
 810               	/* stack size = 3 */
 811               	.L__stack_usage = 3
 203:wl_module.c   **** 	
 812               		.loc 1 203 0
 813 0200 41E0      		ldi r20,lo8(1)
 814 0202 BE01      		movw r22,r28
 815 0204 6F5F      		subi r22,-1
 816 0206 7F4F      		sbci r23,-1
 817 0208 80E0      		ldi r24,0
 818 020a 00D0      		rcall wl_module_read_register
 819               	.LVL62:
 205:wl_module.c   **** 		return;
 820               		.loc 1 205 0
 821 020c 8981      		ldd r24,Y+1
 822 020e 80FF      		sbrs r24,0
 823 0210 00C0      		rjmp .L28
 208:wl_module.c   **** 	
 824               		.loc 1 208 0
 825 0212 8E7F      		andi r24,lo8(-2)
 826 0214 8983      		std Y+1,r24
 210:wl_module.c   **** 
 827               		.loc 1 210 0
 828 0216 41E0      		ldi r20,lo8(1)
 829 0218 BE01      		movw r22,r28
 830 021a 6F5F      		subi r22,-1
 831 021c 7F4F      		sbci r23,-1
 832 021e 80E0      		ldi r24,0
 833 0220 00D0      		rcall wl_module_write_register
 834               	.LVL63:
 212:wl_module.c   **** }
 835               		.loc 1 212 0
 836 0222 2898      		cbi 0x5,0
 837               	.L28:
 838               	/* epilogue start */
 213:wl_module.c   **** 
 839               		.loc 1 213 0
 840 0224 0F90      		pop __tmp_reg__
 841 0226 DF91      		pop r29
 842 0228 CF91      		pop r28
 843 022a 0895      		ret
 844               		.cfi_endproc
 845               	.LFE11:
 847               	.global	wl_module_power_down
 849               	wl_module_power_down:
 850               	.LFB12:
 221:wl_module.c   **** 	unsigned char config;
 851               		.loc 1 221 0
 852               		.cfi_startproc
 853 022c CF93      		push r28
 854               	.LCFI43:
 855               		.cfi_def_cfa_offset 3
 856               		.cfi_offset 28, -2
 857 022e DF93      		push r29
 858               	.LCFI44:
 859               		.cfi_def_cfa_offset 4
 860               		.cfi_offset 29, -3
 861 0230 1F92      		push __zero_reg__
 862               	.LCFI45:
 863               		.cfi_def_cfa_offset 5
 864 0232 CDB7      		in r28,__SP_L__
 865 0234 DEB7      		in r29,__SP_H__
 866               	.LCFI46:
 867               		.cfi_def_cfa_register 28
 868               	/* prologue: function */
 869               	/* frame size = 1 */
 870               	/* stack size = 3 */
 871               	.L__stack_usage = 3
 224:wl_module.c   **** 	
 872               		.loc 1 224 0
 873 0236 41E0      		ldi r20,lo8(1)
 874 0238 BE01      		movw r22,r28
 875 023a 6F5F      		subi r22,-1
 876 023c 7F4F      		sbci r23,-1
 877 023e 80E0      		ldi r24,0
 878 0240 00D0      		rcall wl_module_read_register
 879               	.LVL64:
 226:wl_module.c   **** 		return;
 880               		.loc 1 226 0
 881 0242 8981      		ldd r24,Y+1
 882 0244 81FF      		sbrs r24,1
 883 0246 00C0      		rjmp .L34
 229:wl_module.c   **** 	
 884               		.loc 1 229 0
 885 0248 8D7F      		andi r24,lo8(-3)
 886 024a 8983      		std Y+1,r24
 231:wl_module.c   **** 
 887               		.loc 1 231 0
 888 024c 41E0      		ldi r20,lo8(1)
 889 024e BE01      		movw r22,r28
 890 0250 6F5F      		subi r22,-1
 891 0252 7F4F      		sbci r23,-1
 892 0254 80E0      		ldi r24,0
 893 0256 00D0      		rcall wl_module_write_register
 894               	.LVL65:
 233:wl_module.c   **** }
 895               		.loc 1 233 0
 896 0258 2898      		cbi 0x5,0
 897               	.L34:
 898               	/* epilogue start */
 234:wl_module.c   **** 
 899               		.loc 1 234 0
 900 025a 0F90      		pop __tmp_reg__
 901 025c DF91      		pop r29
 902 025e CF91      		pop r28
 903 0260 0895      		ret
 904               		.cfi_endproc
 905               	.LFE12:
 907               	.global	wl_module_set_rx_addr
 909               	wl_module_set_rx_addr:
 910               	.LFB13:
 245:wl_module.c   **** 	if(rxpipenum > 5)
 911               		.loc 1 245 0
 912               		.cfi_startproc
 913               	.LVL66:
 914               	/* prologue: function */
 915               	/* frame size = 0 */
 916               	/* stack size = 0 */
 917               	.L__stack_usage = 0
 918 0262 9C01      		movw r18,r24
 919 0264 842F      		mov r24,r20
 920               	.LVL67:
 246:wl_module.c   **** 		return;
 921               		.loc 1 246 0
 922 0266 4630      		cpi r20,lo8(6)
 923 0268 00F4      		brsh .L40
 249:wl_module.c   **** }
 924               		.loc 1 249 0
 925 026a 462F      		mov r20,r22
 926               	.LVL68:
 927 026c B901      		movw r22,r18
 928               	.LVL69:
 929 026e 865F      		subi r24,lo8(-(10))
 930               	.LVL70:
 931 0270 00C0      		rjmp wl_module_write_register
 932               	.LVL71:
 933               	.L40:
 934 0272 0895      		ret
 935               		.cfi_endproc
 936               	.LFE13:
 938               	.global	wl_module_rx_config
 940               	wl_module_rx_config:
 941               	.LFB8:
  79:wl_module.c   **** 	uint8_t data[5];
 942               		.loc 1 79 0
 943               		.cfi_startproc
 944 0274 CF93      		push r28
 945               	.LCFI47:
 946               		.cfi_def_cfa_offset 3
 947               		.cfi_offset 28, -2
 948 0276 DF93      		push r29
 949               	.LCFI48:
 950               		.cfi_def_cfa_offset 4
 951               		.cfi_offset 29, -3
 952 0278 00D0      		rcall .
 953 027a 00D0      		rcall .
 954 027c 1F92      		push __zero_reg__
 955               	.LCFI49:
 956               		.cfi_def_cfa_offset 9
 957 027e CDB7      		in r28,__SP_L__
 958 0280 DEB7      		in r29,__SP_H__
 959               	.LCFI50:
 960               		.cfi_def_cfa_register 28
 961               	/* prologue: function */
 962               	/* frame size = 5 */
 963               	/* stack size = 7 */
 964               	.L__stack_usage = 7
  82:wl_module.c   **** 	// Set data speed & Output Power configured in wl_module.h
 965               		.loc 1 82 0
 966 0282 63E0      		ldi r22,lo8(3)
 967 0284 85E0      		ldi r24,lo8(5)
 968 0286 00D0      		rcall wl_module_config_register
 969               	.LVL72:
  84:wl_module.c   **** 	//Enable all RX Data-Pipes
 970               		.loc 1 84 0
 971 0288 66E0      		ldi r22,lo8(6)
 972 028a 86E0      		ldi r24,lo8(6)
 973 028c 00D0      		rcall wl_module_config_register
 974               	.LVL73:
  86:wl_module.c   **** 	//Set RX_Address Pipe 0
 975               		.loc 1 86 0
 976 028e 6FE3      		ldi r22,lo8(63)
 977 0290 82E0      		ldi r24,lo8(2)
 978 0292 00D0      		rcall wl_module_config_register
 979               	.LVL74:
  88:wl_module.c   **** 	wl_module_set_rx_addr(data, 5, 0);
 980               		.loc 1 88 0
 981 0294 87EE      		ldi r24,lo8(-25)
 982 0296 8D83      		std Y+5,r24
 983 0298 8C83      		std Y+4,r24
 984 029a 8B83      		std Y+3,r24
 985 029c 8A83      		std Y+2,r24
 986 029e 8983      		std Y+1,r24
 987               	.LVL75:
 988               	.LBB18:
 989               	.LBB19:
 249:wl_module.c   **** }
 990               		.loc 1 249 0
 991 02a0 45E0      		ldi r20,lo8(5)
 992 02a2 BE01      		movw r22,r28
 993 02a4 6F5F      		subi r22,-1
 994 02a6 7F4F      		sbci r23,-1
 995 02a8 8AE0      		ldi r24,lo8(10)
 996 02aa 00D0      		rcall wl_module_write_register
 997               	.LVL76:
 998               	.LBE19:
 999               	.LBE18:
  91:wl_module.c   **** 	wl_module_set_rx_addr(data, 5, 1);
 1000               		.loc 1 91 0
 1001 02ac 82EC      		ldi r24,lo8(-62)
 1002 02ae 8D83      		std Y+5,r24
 1003 02b0 8C83      		std Y+4,r24
 1004 02b2 8B83      		std Y+3,r24
 1005 02b4 8A83      		std Y+2,r24
 1006 02b6 8983      		std Y+1,r24
 1007               	.LVL77:
 1008               	.LBB20:
 1009               	.LBB21:
 249:wl_module.c   **** }
 1010               		.loc 1 249 0
 1011 02b8 45E0      		ldi r20,lo8(5)
 1012 02ba BE01      		movw r22,r28
 1013 02bc 6F5F      		subi r22,-1
 1014 02be 7F4F      		sbci r23,-1
 1015 02c0 8BE0      		ldi r24,lo8(11)
 1016 02c2 00D0      		rcall wl_module_write_register
 1017               	.LVL78:
 1018               	.LBE21:
 1019               	.LBE20:
  94:wl_module.c   **** 	wl_module_set_rx_addr(data, 1, 2);
 1020               		.loc 1 94 0
 1021 02c4 83EC      		ldi r24,lo8(-61)
 1022 02c6 8983      		std Y+1,r24
 1023               	.LVL79:
 1024               	.LBB22:
 1025               	.LBB23:
 249:wl_module.c   **** }
 1026               		.loc 1 249 0
 1027 02c8 41E0      		ldi r20,lo8(1)
 1028 02ca BE01      		movw r22,r28
 1029 02cc 6F5F      		subi r22,-1
 1030 02ce 7F4F      		sbci r23,-1
 1031 02d0 8CE0      		ldi r24,lo8(12)
 1032 02d2 00D0      		rcall wl_module_write_register
 1033               	.LVL80:
 1034               	.LBE23:
 1035               	.LBE22:
  96:wl_module.c   **** 	wl_module_set_rx_addr(data, 1, 3);
 1036               		.loc 1 96 0
 1037 02d4 84EC      		ldi r24,lo8(-60)
 1038 02d6 8983      		std Y+1,r24
 1039               	.LVL81:
 1040               	.LBB24:
 1041               	.LBB25:
 249:wl_module.c   **** }
 1042               		.loc 1 249 0
 1043 02d8 41E0      		ldi r20,lo8(1)
 1044 02da BE01      		movw r22,r28
 1045 02dc 6F5F      		subi r22,-1
 1046 02de 7F4F      		sbci r23,-1
 1047 02e0 8DE0      		ldi r24,lo8(13)
 1048 02e2 00D0      		rcall wl_module_write_register
 1049               	.LVL82:
 1050               	.LBE25:
 1051               	.LBE24:
  98:wl_module.c   **** 	wl_module_set_rx_addr(data, 1, 4);
 1052               		.loc 1 98 0
 1053 02e4 85EC      		ldi r24,lo8(-59)
 1054 02e6 8983      		std Y+1,r24
 1055               	.LVL83:
 1056               	.LBB26:
 1057               	.LBB27:
 249:wl_module.c   **** }
 1058               		.loc 1 249 0
 1059 02e8 41E0      		ldi r20,lo8(1)
 1060 02ea BE01      		movw r22,r28
 1061 02ec 6F5F      		subi r22,-1
 1062 02ee 7F4F      		sbci r23,-1
 1063 02f0 8EE0      		ldi r24,lo8(14)
 1064 02f2 00D0      		rcall wl_module_write_register
 1065               	.LVL84:
 1066               	.LBE27:
 1067               	.LBE26:
 100:wl_module.c   **** 	wl_module_set_rx_addr(data, 1, 5);
 1068               		.loc 1 100 0
 1069 02f4 86EC      		ldi r24,lo8(-58)
 1070 02f6 8983      		std Y+1,r24
 1071               	.LVL85:
 1072               	.LBB28:
 1073               	.LBB29:
 249:wl_module.c   **** }
 1074               		.loc 1 249 0
 1075 02f8 41E0      		ldi r20,lo8(1)
 1076 02fa BE01      		movw r22,r28
 1077 02fc 6F5F      		subi r22,-1
 1078 02fe 7F4F      		sbci r23,-1
 1079 0300 8FE0      		ldi r24,lo8(15)
 1080 0302 00D0      		rcall wl_module_write_register
 1081               	.LVL86:
 1082               	.LBE29:
 1083               	.LBE28:
 103:wl_module.c   **** 	wl_module_config_register(RX_PW_P1, wl_module_PAYLOAD);
 1084               		.loc 1 103 0
 1085 0304 60E2      		ldi r22,lo8(32)
 1086 0306 81E1      		ldi r24,lo8(17)
 1087 0308 00D0      		rcall wl_module_config_register
 1088               	.LVL87:
 104:wl_module.c   **** 	wl_module_config_register(RX_PW_P2, wl_module_PAYLOAD);
 1089               		.loc 1 104 0
 1090 030a 60E2      		ldi r22,lo8(32)
 1091 030c 82E1      		ldi r24,lo8(18)
 1092 030e 00D0      		rcall wl_module_config_register
 1093               	.LVL88:
 105:wl_module.c   **** 	wl_module_config_register(RX_PW_P3, wl_module_PAYLOAD);
 1094               		.loc 1 105 0
 1095 0310 60E2      		ldi r22,lo8(32)
 1096 0312 83E1      		ldi r24,lo8(19)
 1097 0314 00D0      		rcall wl_module_config_register
 1098               	.LVL89:
 106:wl_module.c   **** 	wl_module_config_register(RX_PW_P4, wl_module_PAYLOAD);
 1099               		.loc 1 106 0
 1100 0316 60E2      		ldi r22,lo8(32)
 1101 0318 84E1      		ldi r24,lo8(20)
 1102 031a 00D0      		rcall wl_module_config_register
 1103               	.LVL90:
 107:wl_module.c   **** 	wl_module_config_register(RX_PW_P5, wl_module_PAYLOAD);
 1104               		.loc 1 107 0
 1105 031c 60E2      		ldi r22,lo8(32)
 1106 031e 85E1      		ldi r24,lo8(21)
 1107 0320 00D0      		rcall wl_module_config_register
 1108               	.LVL91:
 108:wl_module.c   **** 	
 1109               		.loc 1 108 0
 1110 0322 60E2      		ldi r22,lo8(32)
 1111 0324 86E1      		ldi r24,lo8(22)
 1112 0326 00D0      		rcall wl_module_config_register
 1113               	.LVL92:
 112:wl_module.c   ****     RX_POWERUP;     // Power up in receiving mode
 1114               		.loc 1 112 0
 1115 0328 1092 0000 		sts PTX,__zero_reg__
 113:wl_module.c   ****     wl_module_CE_hi;     // Listening for pakets
 1116               		.loc 1 113 0
 1117 032c 6FE0      		ldi r22,lo8(15)
 1118 032e 80E0      		ldi r24,0
 1119 0330 00D0      		rcall wl_module_config_register
 1120               	.LVL93:
 114:wl_module.c   **** }
 1121               		.loc 1 114 0
 1122 0332 289A      		sbi 0x5,0
 1123               	/* epilogue start */
 115:wl_module.c   **** 
 1124               		.loc 1 115 0
 1125 0334 0F90      		pop __tmp_reg__
 1126 0336 0F90      		pop __tmp_reg__
 1127 0338 0F90      		pop __tmp_reg__
 1128 033a 0F90      		pop __tmp_reg__
 1129 033c 0F90      		pop __tmp_reg__
 1130 033e DF91      		pop r29
 1131 0340 CF91      		pop r28
 1132 0342 0895      		ret
 1133               		.cfi_endproc
 1134               	.LFE8:
 1136               	.global	wl_module_set_rx_pw
 1138               	wl_module_set_rx_pw:
 1139               	.LFB15:
 271:wl_module.c   **** 	if((rxpipenum > 5) || (payloadwidth > 32))
 1140               		.loc 1 271 0
 1141               		.cfi_startproc
 1142               	.LVL94:
 1143 0344 CF93      		push r28
 1144               	.LCFI51:
 1145               		.cfi_def_cfa_offset 3
 1146               		.cfi_offset 28, -2
 1147 0346 DF93      		push r29
 1148               	.LCFI52:
 1149               		.cfi_def_cfa_offset 4
 1150               		.cfi_offset 29, -3
 1151 0348 1F92      		push __zero_reg__
 1152               	.LCFI53:
 1153               		.cfi_def_cfa_offset 5
 1154 034a CDB7      		in r28,__SP_L__
 1155 034c DEB7      		in r29,__SP_H__
 1156               	.LCFI54:
 1157               		.cfi_def_cfa_register 28
 1158               	/* prologue: function */
 1159               	/* frame size = 1 */
 1160               	/* stack size = 3 */
 1161               	.L__stack_usage = 3
 1162 034e 8983      		std Y+1,r24
 272:wl_module.c   **** 		return;
 1163               		.loc 1 272 0
 1164 0350 6630      		cpi r22,lo8(6)
 1165 0352 00F4      		brsh .L43
 272:wl_module.c   **** 		return;
 1166               		.loc 1 272 0 is_stmt 0 discriminator 1
 1167 0354 8132      		cpi r24,lo8(33)
 1168 0356 00F4      		brsh .L43
 1169 0358 862F      		mov r24,r22
 1170               	.LVL95:
 275:wl_module.c   **** }
 1171               		.loc 1 275 0 is_stmt 1
 1172 035a 41E0      		ldi r20,lo8(1)
 1173 035c BE01      		movw r22,r28
 1174               	.LVL96:
 1175 035e 6F5F      		subi r22,-1
 1176 0360 7F4F      		sbci r23,-1
 1177 0362 8F5E      		subi r24,lo8(-(17))
 1178               	.LVL97:
 1179 0364 00D0      		rcall wl_module_write_register
 1180               	.LVL98:
 1181               	.L43:
 1182               	/* epilogue start */
 276:wl_module.c   **** 
 1183               		.loc 1 276 0
 1184 0366 0F90      		pop __tmp_reg__
 1185 0368 DF91      		pop r29
 1186 036a CF91      		pop r28
 1187               	.LVL99:
 1188 036c 0895      		ret
 1189               		.cfi_endproc
 1190               	.LFE15:
 1192               	.global	wl_module_set_RADDR
 1194               	wl_module_set_RADDR:
 1195               	.LFB19:
 307:wl_module.c   ****     wl_module_CE_lo;
 1196               		.loc 1 307 0
 1197               		.cfi_startproc
 1198               	.LVL100:
 1199               	/* prologue: function */
 1200               	/* frame size = 0 */
 1201               	/* stack size = 0 */
 1202               	.L__stack_usage = 0
 308:wl_module.c   ****     wl_module_write_register(RX_ADDR_P0,adr,5);
 1203               		.loc 1 308 0
 1204 036e 2898      		cbi 0x5,0
 309:wl_module.c   ****     wl_module_CE_hi;
 1205               		.loc 1 309 0
 1206 0370 45E0      		ldi r20,lo8(5)
 1207 0372 BC01      		movw r22,r24
 1208 0374 8AE0      		ldi r24,lo8(10)
 1209               	.LVL101:
 1210 0376 00D0      		rcall wl_module_write_register
 1211               	.LVL102:
 310:wl_module.c   **** }
 1212               		.loc 1 310 0
 1213 0378 289A      		sbi 0x5,0
 1214 037a 0895      		ret
 1215               		.cfi_endproc
 1216               	.LFE19:
 1218               	.global	wl_module_set_TADDR
 1220               	wl_module_set_TADDR:
 1221               	.LFB20:
 315:wl_module.c   ****     wl_module_write_register(TX_ADDR, adr,5);
 1222               		.loc 1 315 0
 1223               		.cfi_startproc
 1224               	.LVL103:
 1225               	/* prologue: function */
 1226               	/* frame size = 0 */
 1227               	/* stack size = 0 */
 1228               	.L__stack_usage = 0
 316:wl_module.c   **** }
 1229               		.loc 1 316 0
 1230 037c 45E0      		ldi r20,lo8(5)
 1231 037e BC01      		movw r22,r24
 1232 0380 80E1      		ldi r24,lo8(16)
 1233               	.LVL104:
 1234 0382 00C0      		rjmp wl_module_write_register
 1235               	.LVL105:
 1236               		.cfi_endproc
 1237               	.LFE20:
 1239               	.global	wl_module_tx_config
 1241               	wl_module_tx_config:
 1242               	.LFB9:
 122:wl_module.c   **** 	uint8_t tx_addr[5];
 1243               		.loc 1 122 0
 1244               		.cfi_startproc
 1245               	.LVL106:
 1246 0384 1F93      		push r17
 1247               	.LCFI55:
 1248               		.cfi_def_cfa_offset 3
 1249               		.cfi_offset 17, -2
 1250 0386 CF93      		push r28
 1251               	.LCFI56:
 1252               		.cfi_def_cfa_offset 4
 1253               		.cfi_offset 28, -3
 1254 0388 DF93      		push r29
 1255               	.LCFI57:
 1256               		.cfi_def_cfa_offset 5
 1257               		.cfi_offset 29, -4
 1258 038a 00D0      		rcall .
 1259 038c 00D0      		rcall .
 1260 038e 1F92      		push __zero_reg__
 1261               	.LCFI58:
 1262               		.cfi_def_cfa_offset 10
 1263 0390 CDB7      		in r28,__SP_L__
 1264 0392 DEB7      		in r29,__SP_H__
 1265               	.LCFI59:
 1266               		.cfi_def_cfa_register 28
 1267               	/* prologue: function */
 1268               	/* frame size = 5 */
 1269               	/* stack size = 8 */
 1270               	.L__stack_usage = 8
 1271 0394 182F      		mov r17,r24
 126:wl_module.c   **** 	// Set data speed & Output Power configured in wl_module.h
 1272               		.loc 1 126 0
 1273 0396 63E0      		ldi r22,lo8(3)
 1274 0398 85E0      		ldi r24,lo8(5)
 1275               	.LVL107:
 1276 039a 00D0      		rcall wl_module_config_register
 1277               	.LVL108:
 128:wl_module.c   **** 	//Config the CONFIG Register (Mask IRQ, CRC, etc)
 1278               		.loc 1 128 0
 1279 039c 66E0      		ldi r22,lo8(6)
 1280 039e 86E0      		ldi r24,lo8(6)
 1281 03a0 00D0      		rcall wl_module_config_register
 1282               	.LVL109:
 130:wl_module.c   ****     // Set length of incoming payload 
 1283               		.loc 1 130 0
 1284 03a2 6CE0      		ldi r22,lo8(12)
 1285 03a4 80E0      		ldi r24,0
 1286 03a6 00D0      		rcall wl_module_config_register
 1287               	.LVL110:
 134:wl_module.c   **** 	
 1288               		.loc 1 134 0
 1289 03a8 6AE1      		ldi r22,lo8(26)
 1290 03aa 84E0      		ldi r24,lo8(4)
 1291 03ac 00D0      		rcall wl_module_config_register
 1292               	.LVL111:
 137:wl_module.c   **** 			{
 1293               		.loc 1 137 0
 1294 03ae 1230      		cpi r17,lo8(2)
 1295 03b0 01F0      		breq .L49
 1296 03b2 00F4      		brsh .L50
 1297 03b4 1123      		tst r17
 1298 03b6 01F0      		breq .L51
 1299 03b8 1130      		cpi r17,lo8(1)
 1300 03ba 01F4      		brne .L48
 145:wl_module.c   **** 					wl_module_set_TADDR(tx_addr);
 1301               		.loc 1 145 0
 1302 03bc 82EC      		ldi r24,lo8(-62)
 1303 03be 00C0      		rjmp .L57
 1304               	.L50:
 137:wl_module.c   **** 			{
 1305               		.loc 1 137 0
 1306 03c0 1430      		cpi r17,lo8(4)
 1307 03c2 01F0      		breq .L53
 1308 03c4 00F0      		brlo .L54
 1309 03c6 1530      		cpi r17,lo8(5)
 1310 03c8 01F4      		brne .L48
 168:wl_module.c   **** 					tx_addr[0] = RX_ADDR_P5_DEFAULT_VAL;
 1311               		.loc 1 168 0
 1312 03ca 82EC      		ldi r24,lo8(-62)
 1313 03cc 8D83      		std Y+5,r24
 1314 03ce 8C83      		std Y+4,r24
 1315 03d0 8B83      		std Y+3,r24
 1316 03d2 8A83      		std Y+2,r24
 169:wl_module.c   **** 					wl_module_set_TADDR(tx_addr);
 1317               		.loc 1 169 0
 1318 03d4 86EC      		ldi r24,lo8(-58)
 1319 03d6 00C0      		rjmp .L56
 1320               	.L51:
 140:wl_module.c   **** 					wl_module_set_TADDR(tx_addr);
 1321               		.loc 1 140 0
 1322 03d8 87EE      		ldi r24,lo8(-25)
 1323               	.L57:
 145:wl_module.c   **** 					wl_module_set_TADDR(tx_addr);
 1324               		.loc 1 145 0
 1325 03da 8D83      		std Y+5,r24
 1326 03dc 8C83      		std Y+4,r24
 1327 03de 8B83      		std Y+3,r24
 1328 03e0 8A83      		std Y+2,r24
 1329 03e2 00C0      		rjmp .L56
 1330               	.L49:
 150:wl_module.c   **** 					tx_addr[0] = RX_ADDR_P2_DEFAULT_VAL;
 1331               		.loc 1 150 0
 1332 03e4 82EC      		ldi r24,lo8(-62)
 1333 03e6 8D83      		std Y+5,r24
 1334 03e8 8C83      		std Y+4,r24
 1335 03ea 8B83      		std Y+3,r24
 1336 03ec 8A83      		std Y+2,r24
 151:wl_module.c   **** 					wl_module_set_TADDR(tx_addr);
 1337               		.loc 1 151 0
 1338 03ee 83EC      		ldi r24,lo8(-61)
 1339 03f0 00C0      		rjmp .L56
 1340               	.L54:
 156:wl_module.c   **** 					tx_addr[0] = RX_ADDR_P3_DEFAULT_VAL;
 1341               		.loc 1 156 0
 1342 03f2 82EC      		ldi r24,lo8(-62)
 1343 03f4 8D83      		std Y+5,r24
 1344 03f6 8C83      		std Y+4,r24
 1345 03f8 8B83      		std Y+3,r24
 1346 03fa 8A83      		std Y+2,r24
 157:wl_module.c   **** 					wl_module_set_TADDR(tx_addr);
 1347               		.loc 1 157 0
 1348 03fc 84EC      		ldi r24,lo8(-60)
 1349 03fe 00C0      		rjmp .L56
 1350               	.L53:
 162:wl_module.c   **** 					tx_addr[0] = RX_ADDR_P4_DEFAULT_VAL;
 1351               		.loc 1 162 0
 1352 0400 82EC      		ldi r24,lo8(-62)
 1353 0402 8D83      		std Y+5,r24
 1354 0404 8C83      		std Y+4,r24
 1355 0406 8B83      		std Y+3,r24
 1356 0408 8A83      		std Y+2,r24
 163:wl_module.c   **** 					wl_module_set_TADDR(tx_addr);
 1357               		.loc 1 163 0
 1358 040a 85EC      		ldi r24,lo8(-59)
 1359               	.L56:
 169:wl_module.c   **** 					wl_module_set_TADDR(tx_addr);
 1360               		.loc 1 169 0
 1361 040c 8983      		std Y+1,r24
 170:wl_module.c   **** 					wl_module_set_RADDR(tx_addr);
 1362               		.loc 1 170 0
 1363 040e CE01      		movw r24,r28
 1364 0410 0196      		adiw r24,1
 1365 0412 00D0      		rcall wl_module_set_TADDR
 1366               	.LVL112:
 171:wl_module.c   **** 					break;
 1367               		.loc 1 171 0
 1368 0414 CE01      		movw r24,r28
 1369 0416 0196      		adiw r24,1
 1370 0418 00D0      		rcall wl_module_set_RADDR
 1371               	.LVL113:
 1372               	.L48:
 179:wl_module.c   ****     RX_POWERUP;     // Power up in receiving mode
 1373               		.loc 1 179 0
 1374 041a 1092 0000 		sts PTX,__zero_reg__
 180:wl_module.c   ****     wl_module_CE_hi;     // Listening for pakets	
 1375               		.loc 1 180 0
 1376 041e 6FE0      		ldi r22,lo8(15)
 1377 0420 80E0      		ldi r24,0
 1378 0422 00D0      		rcall wl_module_config_register
 1379               	.LVL114:
 181:wl_module.c   **** }
 1380               		.loc 1 181 0
 1381 0424 289A      		sbi 0x5,0
 1382               	/* epilogue start */
 182:wl_module.c   **** 
 1383               		.loc 1 182 0
 1384 0426 0F90      		pop __tmp_reg__
 1385 0428 0F90      		pop __tmp_reg__
 1386 042a 0F90      		pop __tmp_reg__
 1387 042c 0F90      		pop __tmp_reg__
 1388 042e 0F90      		pop __tmp_reg__
 1389 0430 DF91      		pop r29
 1390 0432 CF91      		pop r28
 1391 0434 1F91      		pop r17
 1392               	.LVL115:
 1393 0436 0895      		ret
 1394               		.cfi_endproc
 1395               	.LFE9:
 1397               	.global	wl_module_send
 1399               	wl_module_send:
 1400               	.LFB35:
 472:wl_module.c   **** 
 473:wl_module.c   **** 
 474:wl_module.c   **** void wl_module_send(uint8_t * value, uint8_t len) 
 475:wl_module.c   **** // Sends a data package to the default address. Be sure to send the correct
 476:wl_module.c   **** // amount of bytes as configured as payload on the receiver.
 477:wl_module.c   **** {
 1401               		.loc 1 477 0
 1402               		.cfi_startproc
 1403               	.LVL116:
 1404 0438 1F93      		push r17
 1405               	.LCFI60:
 1406               		.cfi_def_cfa_offset 3
 1407               		.cfi_offset 17, -2
 1408 043a CF93      		push r28
 1409               	.LCFI61:
 1410               		.cfi_def_cfa_offset 4
 1411               		.cfi_offset 28, -3
 1412 043c DF93      		push r29
 1413               	.LCFI62:
 1414               		.cfi_def_cfa_offset 5
 1415               		.cfi_offset 29, -4
 1416               	/* prologue: function */
 1417               	/* frame size = 0 */
 1418               	/* stack size = 3 */
 1419               	.L__stack_usage = 3
 1420 043e EC01      		movw r28,r24
 1421 0440 162F      		mov r17,r22
 1422               	.LVL117:
 1423               	.L59:
 478:wl_module.c   ****     while (PTX) 
 1424               		.loc 1 478 0 discriminator 1
 1425 0442 8091 0000 		lds r24,PTX
 1426 0446 8111      		cpse r24,__zero_reg__
 1427 0448 00C0      		rjmp .L59
 479:wl_module.c   **** 	{}                  // Wait until last paket is send
 480:wl_module.c   **** 
 481:wl_module.c   ****     wl_module_CE_lo;
 1428               		.loc 1 481 0
 1429 044a 2898      		cbi 0x5,0
 482:wl_module.c   **** 
 483:wl_module.c   ****     PTX = 1;                        // Set to transmitter mode
 1430               		.loc 1 483 0
 1431 044c 81E0      		ldi r24,lo8(1)
 1432 044e 8093 0000 		sts PTX,r24
 484:wl_module.c   ****     TX_POWERUP;                     // Power up
 1433               		.loc 1 484 0
 1434 0452 6EE0      		ldi r22,lo8(14)
 1435               	.LVL118:
 1436 0454 80E0      		ldi r24,0
 1437 0456 00D0      		rcall wl_module_config_register
 1438               	.LVL119:
 485:wl_module.c   ****     
 486:wl_module.c   ****     wl_module_CSN_lo;                    // Pull down chip select
 1439               		.loc 1 486 0
 1440 0458 2A98      		cbi 0x5,2
 487:wl_module.c   ****     spi_fast_shift( FLUSH_TX );     // Write cmd to flush tx fifo
 1441               		.loc 1 487 0
 1442 045a 81EE      		ldi r24,lo8(-31)
 1443 045c 00D0      		rcall spi_fast_shift
 1444               	.LVL120:
 488:wl_module.c   ****     wl_module_CSN_hi;                    // Pull up chip select
 1445               		.loc 1 488 0
 1446 045e 2A9A      		sbi 0x5,2
 489:wl_module.c   ****     
 490:wl_module.c   ****     wl_module_CSN_lo;                    // Pull down chip select
 1447               		.loc 1 490 0
 1448 0460 2A98      		cbi 0x5,2
 491:wl_module.c   ****     spi_fast_shift( W_TX_PAYLOAD ); // Write cmd to write payload
 1449               		.loc 1 491 0
 1450 0462 80EA      		ldi r24,lo8(-96)
 1451 0464 00D0      		rcall spi_fast_shift
 1452               	.LVL121:
 492:wl_module.c   ****     spi_transmit_sync(value,len);   // Write payload
 1453               		.loc 1 492 0
 1454 0466 612F      		mov r22,r17
 1455 0468 CE01      		movw r24,r28
 1456 046a 00D0      		rcall spi_transmit_sync
 1457               	.LVL122:
 493:wl_module.c   ****     wl_module_CSN_hi;                    // Pull up chip select
 1458               		.loc 1 493 0
 1459 046c 2A9A      		sbi 0x5,2
 494:wl_module.c   ****     
 495:wl_module.c   ****     wl_module_CE_hi;                     // Start transmission
 1460               		.loc 1 495 0
 1461 046e 289A      		sbi 0x5,0
 1462               	.LVL123:
 1463               	.LBB30:
 1464               	.LBB31:
 1465               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:c:\winavr-20100110\avr\include\util\delay.h **** 
 189:c:\winavr-20100110\avr\include\util\delay.h **** #else
 190:c:\winavr-20100110\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\winavr-20100110\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\winavr-20100110\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\winavr-20100110\avr\include\util\delay.h **** 	{
 196:c:\winavr-20100110\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\winavr-20100110\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\winavr-20100110\avr\include\util\delay.h **** 		{
 200:c:\winavr-20100110\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\winavr-20100110\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\winavr-20100110\avr\include\util\delay.h **** 			__ticks --;
 203:c:\winavr-20100110\avr\include\util\delay.h **** 		}
 204:c:\winavr-20100110\avr\include\util\delay.h **** 		return;
 205:c:\winavr-20100110\avr\include\util\delay.h **** 	}
 206:c:\winavr-20100110\avr\include\util\delay.h **** 	else
 207:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\winavr-20100110\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 210:c:\winavr-20100110\avr\include\util\delay.h **** }
 211:c:\winavr-20100110\avr\include\util\delay.h **** 
 212:c:\winavr-20100110\avr\include\util\delay.h **** /**
 213:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\winavr-20100110\avr\include\util\delay.h **** 
 215:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\winavr-20100110\avr\include\util\delay.h **** 
 217:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\winavr-20100110\avr\include\util\delay.h **** 
 220:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\winavr-20100110\avr\include\util\delay.h **** 
 222:c:\winavr-20100110\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\winavr-20100110\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\winavr-20100110\avr\include\util\delay.h **** 
 226:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\winavr-20100110\avr\include\util\delay.h **** 
 231:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\winavr-20100110\avr\include\util\delay.h **** 
 236:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 240:c:\winavr-20100110\avr\include\util\delay.h **** 
 241:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 242:c:\winavr-20100110\avr\include\util\delay.h **** 
 243:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\winavr-20100110\avr\include\util\delay.h **** 
 253:c:\winavr-20100110\avr\include\util\delay.h ****  */
 254:c:\winavr-20100110\avr\include\util\delay.h **** void
 255:c:\winavr-20100110\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\winavr-20100110\avr\include\util\delay.h **** {
 257:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\winavr-20100110\avr\include\util\delay.h **** 
 265:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\winavr-20100110\avr\include\util\delay.h **** 
 268:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\winavr-20100110\avr\include\util\delay.h **** 
 271:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 272:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 273:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 275:c:\winavr-20100110\avr\include\util\delay.h **** 
 276:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1466               		.loc 2 276 0
 1467 0470 82E3      		ldi r24,lo8(50)
 1468 0472 8A95      	1:	dec r24
 1469 0474 01F4      		brne 1b
 1470               	.LVL124:
 1471               	.LBE31:
 1472               	.LBE30:
 496:wl_module.c   **** 	_delay_us(15);						// Grnes Modul funktioniert nicht mit 10s delay
 497:wl_module.c   **** 	wl_module_CE_lo;
 1473               		.loc 1 497 0
 1474 0476 2898      		cbi 0x5,0
 1475               	/* epilogue start */
 498:wl_module.c   **** }
 1476               		.loc 1 498 0
 1477 0478 DF91      		pop r29
 1478 047a CF91      		pop r28
 1479               	.LVL125:
 1480 047c 1F91      		pop r17
 1481               	.LVL126:
 1482 047e 0895      		ret
 1483               		.cfi_endproc
 1484               	.LFE35:
 1486               	.Letext0:
 1487               		.file 3 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 1488               		.file 4 "spi.h"
DEFINED SYMBOLS
                            *ABS*:00000000 wl_module.c
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:2      *ABS*:0000003e __SP_H__
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:3      *ABS*:0000003d __SP_L__
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:4      *ABS*:0000003f __SREG__
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:6      *ABS*:00000001 __zero_reg__
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:12     .text:00000000 wl_module_init
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:37     .text:0000000a wl_module_get_rx_pipe_from_status
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:57     .text:00000010 wl_module_data_ready
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:91     .text:00000028 wl_module_get_one_byte
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:114    .text:00000030 wl_module_get_status
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:131    .text:00000034 wl_module_get_rx_pipe
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:151    .text:0000003c wl_module_get_rx_pipe_reading_status
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:174    .text:00000046 wl_module_get_data
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:227    .text:0000006a wl_module_config_register
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:275    .text:00000088 wl_module_config
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:313    .text:000000a8 wl_module_read_register
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:364    .text:000000ca wl_module_get_rx_addr
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:393    .text:000000da wl_module_get_rx_pw
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:449    .text:00000102 wl_module_fifo_tx_empty
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:494    .text:00000124 wl_module_fifo_rx_empty
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:539    .text:00000146 wl_module_get_rf_ch
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:582    .text:00000166 wl_module_get_rf_setup
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:625    .text:00000186 wl_module_get_plos_cnt
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:671    .text:000001aa wl_module_get_arc_cnt
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:716    .text:000001cc wl_module_write_register
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:767    .text:000001ee wl_module_set_tx_addr
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:789    .text:000001f6 wl_module_set_as_tx
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:849    .text:0000022c wl_module_power_down
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:909    .text:00000262 wl_module_set_rx_addr
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:940    .text:00000274 wl_module_rx_config
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:1138   .text:00000344 wl_module_set_rx_pw
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:1194   .text:0000036e wl_module_set_RADDR
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:1220   .text:0000037c wl_module_set_TADDR
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:1241   .text:00000384 wl_module_tx_config
C:\Users\mcmai\AppData\Local\Temp\ccz4LKfW.s:1399   .text:00000438 wl_module_send

UNDEFINED SYMBOLS
spi_init
PTX
spi_fast_shift
spi_transfer_sync
spi_transmit_sync
