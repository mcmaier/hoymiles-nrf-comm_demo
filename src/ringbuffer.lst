   1               		.file	"ringbuffer.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	ringbuffer__init
  12               	ringbuffer__init:
  13               	.LFB0:
  14               		.file 1 "ringbuffer.c"
   1:ringbuffer.c  **** /*
   2:ringbuffer.c  **** 	Copyright (c) 2022 by Martin Maier (martin@mcmaier.net)
   3:ringbuffer.c  **** 	
   4:ringbuffer.c  ****     Permission is hereby granted, free of charge, to any person 
   5:ringbuffer.c  ****     obtaining a copy of this software and associated documentation 
   6:ringbuffer.c  ****     files (the "Software"), to deal in the Software without 
   7:ringbuffer.c  ****     restriction, including without limitation the rights to use, copy, 
   8:ringbuffer.c  ****     modify, merge, publish, distribute, sublicense, and/or sell copies 
   9:ringbuffer.c  ****     of the Software, and to permit persons to whom the Software is 
  10:ringbuffer.c  ****     furnished to do so, subject to the following conditions:
  11:ringbuffer.c  **** 
  12:ringbuffer.c  ****     The above copyright notice and this permission notice shall be 
  13:ringbuffer.c  ****     included in all copies or substantial portions of the Software.
  14:ringbuffer.c  **** 
  15:ringbuffer.c  ****     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
  16:ringbuffer.c  ****     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
  17:ringbuffer.c  ****     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
  18:ringbuffer.c  ****     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
  19:ringbuffer.c  ****     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
  20:ringbuffer.c  ****     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
  21:ringbuffer.c  ****     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
  22:ringbuffer.c  ****     DEALINGS IN THE SOFTWARE.    
  23:ringbuffer.c  **** */
  24:ringbuffer.c  **** 
  25:ringbuffer.c  **** #ifndef RINGBUFFER_C
  26:ringbuffer.c  **** #define RINGBUFFER_C
  27:ringbuffer.c  **** 
  28:ringbuffer.c  **** #include "ringbuffer.h"
  29:ringbuffer.c  **** 
  30:ringbuffer.c  **** //******************************************************************************
  31:ringbuffer.c  **** // INTERNAL VARIABLES
  32:ringbuffer.c  **** //******************************************************************************
  33:ringbuffer.c  **** 
  34:ringbuffer.c  **** //******************************************************************************
  35:ringbuffer.c  **** // FUNCTIONS
  36:ringbuffer.c  **** //******************************************************************************
  37:ringbuffer.c  **** 
  38:ringbuffer.c  **** //Ringbuffer_State_t ringbuffer__init(Ringbuffer_t *buffer, uint8_t *p_array, uint8_t buf_size, uin
  39:ringbuffer.c  **** //Initializes a buffer with the selected values 
  40:ringbuffer.c  **** //------------------------------------------------------------------------------
  41:ringbuffer.c  **** Ringbuffer_State_t ringbuffer__init(Ringbuffer_t *buffer, uint8_t *p_array, uint8_t buf_size, uint8
  42:ringbuffer.c  **** {
  15               		.loc 1 42 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  22 0000 FC01      		movw r30,r24
  43:ringbuffer.c  ****   if((buf_width != 1) || (buf_width != 2) || (buf_width != 4))
  44:ringbuffer.c  ****   {
  45:ringbuffer.c  ****     buffer->state = BUFFER_empty;  
  23               		.loc 1 45 0
  24 0002 81E0      		ldi r24,lo8(1)
  25               	.LVL1:
  26 0004 8083      		st Z,r24
  46:ringbuffer.c  ****     buffer->write_pos = 0;
  27               		.loc 1 46 0
  28 0006 1282      		std Z+2,__zero_reg__
  47:ringbuffer.c  ****     buffer->read_pos = 0;
  29               		.loc 1 47 0
  30 0008 1182      		std Z+1,__zero_reg__
  48:ringbuffer.c  ****     buffer->busy = 0;
  31               		.loc 1 48 0
  32 000a 1582      		std Z+5,__zero_reg__
  49:ringbuffer.c  ****     buffer->size = buf_size;
  33               		.loc 1 49 0
  34 000c 4383      		std Z+3,r20
  50:ringbuffer.c  ****     buffer->width = buf_width;
  35               		.loc 1 50 0
  36 000e 2483      		std Z+4,r18
  51:ringbuffer.c  ****     buffer->p_buffer_data = p_array;
  37               		.loc 1 51 0
  38 0010 7783      		std Z+7,r23
  39 0012 6683      		std Z+6,r22
  52:ringbuffer.c  ****   }
  53:ringbuffer.c  ****   else
  54:ringbuffer.c  ****   { 
  55:ringbuffer.c  ****     buffer->state = BUFFER_invalid;  
  56:ringbuffer.c  ****   }
  57:ringbuffer.c  **** 
  58:ringbuffer.c  ****   return buffer->state;
  59:ringbuffer.c  **** }
  40               		.loc 1 59 0
  41 0014 0895      		ret
  42               		.cfi_endproc
  43               	.LFE0:
  45               	.global	ringbuffer__push
  47               	ringbuffer__push:
  48               	.LFB1:
  60:ringbuffer.c  **** 
  61:ringbuffer.c  **** //Ringbuffer_State_t  ringbuffer__push(Ringbuffer_t* buffer, uint8_t* data)
  62:ringbuffer.c  **** //Pushes an element into a buffer
  63:ringbuffer.c  **** //Returns state of buffer, Overflow in case buffer is full
  64:ringbuffer.c  **** //------------------------------------------------------------------------------
  65:ringbuffer.c  **** Ringbuffer_State_t  ringbuffer__push(Ringbuffer_t* buffer, uint8_t* data)
  66:ringbuffer.c  **** {   
  49               		.loc 1 66 0
  50               		.cfi_startproc
  51               	.LVL2:
  52 0016 CF93      		push r28
  53               	.LCFI0:
  54               		.cfi_def_cfa_offset 3
  55               		.cfi_offset 28, -2
  56 0018 DF93      		push r29
  57               	.LCFI1:
  58               		.cfi_def_cfa_offset 4
  59               		.cfi_offset 29, -3
  60               	/* prologue: function */
  61               	/* frame size = 0 */
  62               	/* stack size = 2 */
  63               	.L__stack_usage = 2
  64 001a EC01      		movw r28,r24
  67:ringbuffer.c  ****   //Check if buffer is full
  68:ringbuffer.c  ****   if(buffer->state == BUFFER_full)
  65               		.loc 1 68 0
  66 001c 8881      		ld r24,Y
  67               	.LVL3:
  68 001e 8330      		cpi r24,lo8(3)
  69 0020 01F0      		breq .L6
  69:ringbuffer.c  ****   {
  70:ringbuffer.c  ****     return BUFFER_overflow;
  71:ringbuffer.c  ****   }
  72:ringbuffer.c  ****   else if(buffer->state == BUFFER_invalid)
  70               		.loc 1 72 0
  71 0022 8823      		tst r24
  72 0024 01F0      		breq .L3
  73:ringbuffer.c  ****   {
  74:ringbuffer.c  ****     return BUFFER_invalid;
  75:ringbuffer.c  ****   }
  76:ringbuffer.c  ****   else
  77:ringbuffer.c  ****   {
  78:ringbuffer.c  ****     buffer->busy = 1;
  73               		.loc 1 78 0
  74 0026 81E0      		ldi r24,lo8(1)
  75 0028 8D83      		std Y+5,r24
  79:ringbuffer.c  ****     memcpy((void *)(&buffer->p_buffer_data[buffer->write_pos * buffer->width]), (void *)data, buffe
  76               		.loc 1 79 0
  77 002a 9C81      		ldd r25,Y+4
  78 002c 8A81      		ldd r24,Y+2
  79 002e 2E81      		ldd r18,Y+6
  80 0030 3F81      		ldd r19,Y+7
  81 0032 492F      		mov r20,r25
  82 0034 50E0      		ldi r21,0
  83 0036 F901      		movw r30,r18
  84 0038 899F      		mul r24,r25
  85 003a E00D      		add r30,r0
  86 003c F11D      		adc r31,r1
  87 003e 1124      		clr __zero_reg__
  88 0040 CF01      		movw r24,r30
  89 0042 00D0      		rcall memcpy
  90               	.LVL4:
  80:ringbuffer.c  ****     buffer->write_pos = (buffer->write_pos + 1) & (buffer->size - 1);
  91               		.loc 1 80 0
  92 0044 8A81      		ldd r24,Y+2
  93 0046 91E0      		ldi r25,lo8(1)
  94 0048 980F      		add r25,r24
  95 004a 8B81      		ldd r24,Y+3
  96 004c 8150      		subi r24,lo8(-(-1))
  97 004e 8923      		and r24,r25
  98 0050 8A83      		std Y+2,r24
  81:ringbuffer.c  ****     
  82:ringbuffer.c  ****     if(buffer->write_pos == buffer->read_pos)
  99               		.loc 1 82 0
 100 0052 9981      		ldd r25,Y+1
 101 0054 8913      		cpse r24,r25
 102 0056 00C0      		rjmp .L4
  83:ringbuffer.c  ****     {
  84:ringbuffer.c  ****       buffer->state = BUFFER_full;
 103               		.loc 1 84 0
 104 0058 83E0      		ldi r24,lo8(3)
 105 005a 00C0      		rjmp .L10
 106               	.L4:
  85:ringbuffer.c  ****     }
  86:ringbuffer.c  ****     else
  87:ringbuffer.c  ****     {
  88:ringbuffer.c  ****       buffer->state = BUFFER_normal;
 107               		.loc 1 88 0
 108 005c 82E0      		ldi r24,lo8(2)
 109               	.L10:
 110 005e 8883      		st Y,r24
  89:ringbuffer.c  ****     }
  90:ringbuffer.c  ****     
  91:ringbuffer.c  ****     buffer->busy = 0;
 111               		.loc 1 91 0
 112 0060 1D82      		std Y+5,__zero_reg__
  92:ringbuffer.c  ****            
  93:ringbuffer.c  ****     return buffer->state;
 113               		.loc 1 93 0
 114 0062 8881      		ld r24,Y
 115 0064 00C0      		rjmp .L3
 116               	.LVL5:
 117               	.L6:
  70:ringbuffer.c  ****   }
 118               		.loc 1 70 0
 119 0066 84E0      		ldi r24,lo8(4)
 120               	.LVL6:
 121               	.L3:
 122               	/* epilogue start */
  94:ringbuffer.c  ****   }
  95:ringbuffer.c  **** }
 123               		.loc 1 95 0
 124 0068 DF91      		pop r29
 125 006a CF91      		pop r28
 126               	.LVL7:
 127 006c 0895      		ret
 128               		.cfi_endproc
 129               	.LFE1:
 131               	.global	ringbuffer__pop
 133               	ringbuffer__pop:
 134               	.LFB2:
  96:ringbuffer.c  **** 
  97:ringbuffer.c  **** //Ringbuffer_State_t ringbuffer__pop(Ringbuffer_t *buffer, uint8_t *data)
  98:ringbuffer.c  **** //Gets an element out of the buffer
  99:ringbuffer.c  **** //------------------------------------------------------------------------------
 100:ringbuffer.c  **** Ringbuffer_State_t ringbuffer__pop(Ringbuffer_t *buffer, uint8_t *data)
 101:ringbuffer.c  **** {  
 135               		.loc 1 101 0
 136               		.cfi_startproc
 137               	.LVL8:
 138 006e 1F93      		push r17
 139               	.LCFI2:
 140               		.cfi_def_cfa_offset 3
 141               		.cfi_offset 17, -2
 142 0070 CF93      		push r28
 143               	.LCFI3:
 144               		.cfi_def_cfa_offset 4
 145               		.cfi_offset 28, -3
 146 0072 DF93      		push r29
 147               	.LCFI4:
 148               		.cfi_def_cfa_offset 5
 149               		.cfi_offset 29, -4
 150               	/* prologue: function */
 151               	/* frame size = 0 */
 152               	/* stack size = 3 */
 153               	.L__stack_usage = 3
 154 0074 EC01      		movw r28,r24
 102:ringbuffer.c  ****   //Return error if buffer is empty
 103:ringbuffer.c  ****   if(buffer->state == BUFFER_empty)
 155               		.loc 1 103 0
 156 0076 8881      		ld r24,Y
 157               	.LVL9:
 158 0078 8130      		cpi r24,lo8(1)
 159 007a 01F0      		breq .L16
 104:ringbuffer.c  ****   {
 105:ringbuffer.c  ****     return BUFFER_underrun;
 106:ringbuffer.c  ****   }
 107:ringbuffer.c  ****   else if(buffer->state == BUFFER_invalid)
 160               		.loc 1 107 0
 161 007c 8823      		tst r24
 162 007e 01F0      		breq .L13
 163 0080 9B01      		movw r18,r22
 108:ringbuffer.c  ****   {
 109:ringbuffer.c  ****     return BUFFER_invalid;
 110:ringbuffer.c  ****   }
 111:ringbuffer.c  ****   else
 112:ringbuffer.c  ****   {
 113:ringbuffer.c  ****     buffer->busy = 1;
 164               		.loc 1 113 0
 165 0082 11E0      		ldi r17,lo8(1)
 166 0084 1D83      		std Y+5,r17
 114:ringbuffer.c  **** 
 115:ringbuffer.c  ****     memcpy((void *)data, (void *)(&buffer->p_buffer_data[buffer->read_pos * buffer->width]), buffer
 167               		.loc 1 115 0
 168 0086 8C81      		ldd r24,Y+4
 169 0088 9981      		ldd r25,Y+1
 170 008a 482F      		mov r20,r24
 171 008c 50E0      		ldi r21,0
 172 008e 6E81      		ldd r22,Y+6
 173 0090 7F81      		ldd r23,Y+7
 174               	.LVL10:
 175 0092 989F      		mul r25,r24
 176 0094 600D      		add r22,r0
 177 0096 711D      		adc r23,r1
 178 0098 1124      		clr __zero_reg__
 179 009a C901      		movw r24,r18
 180 009c 00D0      		rcall memcpy
 181               	.LVL11:
 116:ringbuffer.c  ****     buffer->read_pos = (buffer->read_pos + 1) & (buffer->size - 1);
 182               		.loc 1 116 0
 183 009e 8981      		ldd r24,Y+1
 184 00a0 91E0      		ldi r25,lo8(1)
 185 00a2 980F      		add r25,r24
 186 00a4 8B81      		ldd r24,Y+3
 187 00a6 8150      		subi r24,lo8(-(-1))
 188 00a8 8923      		and r24,r25
 189 00aa 8983      		std Y+1,r24
 117:ringbuffer.c  **** 
 118:ringbuffer.c  ****     //Wenn Leseposition = Schreibposition
 119:ringbuffer.c  ****     if(buffer->read_pos == buffer->write_pos)
 190               		.loc 1 119 0
 191 00ac 9A81      		ldd r25,Y+2
 192 00ae 8913      		cpse r24,r25
 193 00b0 00C0      		rjmp .L14
 120:ringbuffer.c  ****     {
 121:ringbuffer.c  ****       //Pufferzustand leer
 122:ringbuffer.c  ****       buffer->state = BUFFER_empty;
 194               		.loc 1 122 0
 195 00b2 1883      		st Y,r17
 196 00b4 00C0      		rjmp .L15
 197               	.L14:
 123:ringbuffer.c  ****     }
 124:ringbuffer.c  ****     //Sonst Pufferzustand normal
 125:ringbuffer.c  ****     else
 126:ringbuffer.c  ****     {
 127:ringbuffer.c  ****       buffer->state = BUFFER_normal;
 198               		.loc 1 127 0
 199 00b6 82E0      		ldi r24,lo8(2)
 200 00b8 8883      		st Y,r24
 201               	.L15:
 128:ringbuffer.c  ****     }
 129:ringbuffer.c  ****     
 130:ringbuffer.c  ****     buffer->busy = 0;
 202               		.loc 1 130 0
 203 00ba 1D82      		std Y+5,__zero_reg__
 131:ringbuffer.c  **** 
 132:ringbuffer.c  ****     return buffer->state;
 204               		.loc 1 132 0
 205 00bc 8881      		ld r24,Y
 206 00be 00C0      		rjmp .L13
 207               	.LVL12:
 208               	.L16:
 105:ringbuffer.c  ****   }
 209               		.loc 1 105 0
 210 00c0 85E0      		ldi r24,lo8(5)
 211               	.LVL13:
 212               	.L13:
 213               	/* epilogue start */
 133:ringbuffer.c  ****   }  
 134:ringbuffer.c  **** }
 214               		.loc 1 134 0
 215 00c2 DF91      		pop r29
 216 00c4 CF91      		pop r28
 217               	.LVL14:
 218 00c6 1F91      		pop r17
 219 00c8 0895      		ret
 220               		.cfi_endproc
 221               	.LFE2:
 223               	.global	ringbuffer__flush
 225               	ringbuffer__flush:
 226               	.LFB3:
 135:ringbuffer.c  **** 
 136:ringbuffer.c  **** // Ringbuffer_State_t  ringbuffer__flush(Ringbuffer_t* buffer)
 137:ringbuffer.c  **** // Clears all items of the buffer
 138:ringbuffer.c  **** //------------------------------------------------------------------------------
 139:ringbuffer.c  **** Ringbuffer_State_t ringbuffer__flush(Ringbuffer_t *buffer)
 140:ringbuffer.c  **** {
 227               		.loc 1 140 0
 228               		.cfi_startproc
 229               	.LVL15:
 230               	/* prologue: function */
 231               	/* frame size = 0 */
 232               	/* stack size = 0 */
 233               	.L__stack_usage = 0
 234 00ca FC01      		movw r30,r24
 141:ringbuffer.c  ****   if(buffer->state == BUFFER_invalid)
 235               		.loc 1 141 0
 236 00cc 8081      		ld r24,Z
 237               	.LVL16:
 238 00ce 8823      		tst r24
 239 00d0 01F0      		breq .L21
 142:ringbuffer.c  ****   {
 143:ringbuffer.c  ****     return BUFFER_invalid;
 144:ringbuffer.c  ****   }
 145:ringbuffer.c  ****   else
 146:ringbuffer.c  ****   {
 147:ringbuffer.c  ****     buffer->busy = 1;
 148:ringbuffer.c  ****     buffer->write_pos = buffer->read_pos;
 240               		.loc 1 148 0
 241 00d2 8181      		ldd r24,Z+1
 242 00d4 8283      		std Z+2,r24
 149:ringbuffer.c  ****     buffer->state = BUFFER_empty;
 243               		.loc 1 149 0
 244 00d6 81E0      		ldi r24,lo8(1)
 245 00d8 8083      		st Z,r24
 150:ringbuffer.c  ****     buffer->busy = 0;
 246               		.loc 1 150 0
 247 00da 1582      		std Z+5,__zero_reg__
 248               	.L21:
 151:ringbuffer.c  **** 
 152:ringbuffer.c  ****     return buffer->state;
 153:ringbuffer.c  ****   }
 154:ringbuffer.c  **** }
 249               		.loc 1 154 0
 250 00dc 0895      		ret
 251               		.cfi_endproc
 252               	.LFE3:
 254               	.global	ringbuffer__get_state
 256               	ringbuffer__get_state:
 257               	.LFB4:
 155:ringbuffer.c  **** 
 156:ringbuffer.c  **** // Ringbuffer_State_t  ringbuffer__get_state(Ringbuffer_t* buffer)
 157:ringbuffer.c  **** // returns the state of the ringbuffer
 158:ringbuffer.c  **** //------------------------------------------------------------------------------
 159:ringbuffer.c  **** Ringbuffer_State_t  ringbuffer__get_state(Ringbuffer_t* buffer)
 160:ringbuffer.c  **** { 
 258               		.loc 1 160 0
 259               		.cfi_startproc
 260               	.LVL17:
 261               	/* prologue: function */
 262               	/* frame size = 0 */
 263               	/* stack size = 0 */
 264               	.L__stack_usage = 0
 161:ringbuffer.c  ****   return buffer->state;
 162:ringbuffer.c  **** }
 265               		.loc 1 162 0
 266 00de FC01      		movw r30,r24
 267 00e0 8081      		ld r24,Z
 268               	.LVL18:
 269 00e2 0895      		ret
 270               		.cfi_endproc
 271               	.LFE4:
 273               	.global	ringbuffer__contains
 275               	ringbuffer__contains:
 276               	.LFB5:
 163:ringbuffer.c  **** 
 164:ringbuffer.c  **** // bool ringbuffer__contains_element(Ringbuffer_t, uint8_t * )
 165:ringbuffer.c  **** // returns true, if the ringbuffer contains the element at least one time
 166:ringbuffer.c  **** //------------------------------------------------------------------------------
 167:ringbuffer.c  **** uint8_t ringbuffer__contains(Ringbuffer_t * buffer, void* compare_element)
 168:ringbuffer.c  **** {
 277               		.loc 1 168 0
 278               		.cfi_startproc
 279               	.LVL19:
 280 00e4 8F92      		push r8
 281               	.LCFI5:
 282               		.cfi_def_cfa_offset 3
 283               		.cfi_offset 8, -2
 284 00e6 9F92      		push r9
 285               	.LCFI6:
 286               		.cfi_def_cfa_offset 4
 287               		.cfi_offset 9, -3
 288 00e8 AF92      		push r10
 289               	.LCFI7:
 290               		.cfi_def_cfa_offset 5
 291               		.cfi_offset 10, -4
 292 00ea BF92      		push r11
 293               	.LCFI8:
 294               		.cfi_def_cfa_offset 6
 295               		.cfi_offset 11, -5
 296 00ec CF92      		push r12
 297               	.LCFI9:
 298               		.cfi_def_cfa_offset 7
 299               		.cfi_offset 12, -6
 300 00ee DF92      		push r13
 301               	.LCFI10:
 302               		.cfi_def_cfa_offset 8
 303               		.cfi_offset 13, -7
 304 00f0 EF92      		push r14
 305               	.LCFI11:
 306               		.cfi_def_cfa_offset 9
 307               		.cfi_offset 14, -8
 308 00f2 FF92      		push r15
 309               	.LCFI12:
 310               		.cfi_def_cfa_offset 10
 311               		.cfi_offset 15, -9
 312 00f4 CF93      		push r28
 313               	.LCFI13:
 314               		.cfi_def_cfa_offset 11
 315               		.cfi_offset 28, -10
 316 00f6 DF93      		push r29
 317               	.LCFI14:
 318               		.cfi_def_cfa_offset 12
 319               		.cfi_offset 29, -11
 320               	/* prologue: function */
 321               	/* frame size = 0 */
 322               	/* stack size = 10 */
 323               	.L__stack_usage = 10
 324 00f8 FC01      		movw r30,r24
 325 00fa EB01      		movw r28,r22
 326               	.LVL20:
 169:ringbuffer.c  ****   uint8_t count = 0;
 170:ringbuffer.c  ****   uint8_t read_offset = 0;
 171:ringbuffer.c  **** 
 172:ringbuffer.c  ****   //Wenn kein Element vorhanden,
 173:ringbuffer.c  ****   if ((buffer->state == BUFFER_empty) || (buffer->state == BUFFER_invalid))
 327               		.loc 1 173 0
 328 00fc 8081      		ld r24,Z
 329               	.LVL21:
 330 00fe 8230      		cpi r24,lo8(2)
 331 0100 00F4      		brsh .+2
 332 0102 00C0      		rjmp .L33
 174:ringbuffer.c  ****   {
 175:ringbuffer.c  ****     return 0;
 176:ringbuffer.c  ****   }
 177:ringbuffer.c  ****   else
 178:ringbuffer.c  ****   {
 179:ringbuffer.c  ****     buffer->busy = 1;
 333               		.loc 1 179 0
 334 0104 81E0      		ldi r24,lo8(1)
 335 0106 8583      		std Z+5,r24
 180:ringbuffer.c  **** 
 181:ringbuffer.c  ****     do
 182:ringbuffer.c  ****     {
 183:ringbuffer.c  ****       switch(buffer->width)
 336               		.loc 1 183 0
 337 0108 6481      		ldd r22,Z+4
 338               	.LVL22:
 184:ringbuffer.c  ****       {
 185:ringbuffer.c  ****         case 1:
 186:ringbuffer.c  ****           if (*((uint8_t*)compare_element) == *((uint8_t*)(&buffer->p_buffer_data[(buffer->read_pos
 187:ringbuffer.c  ****           {
 188:ringbuffer.c  ****             count++;
 189:ringbuffer.c  ****           }
 190:ringbuffer.c  ****           break;
 191:ringbuffer.c  **** 
 192:ringbuffer.c  ****         case 2:
 193:ringbuffer.c  ****           if (*((uint16_t*)compare_element) == *((uint16_t *)(&buffer->p_buffer_data[(buffer->read_
 194:ringbuffer.c  ****           {
 195:ringbuffer.c  ****             count++;
 196:ringbuffer.c  ****           }
 197:ringbuffer.c  ****         break;
 198:ringbuffer.c  **** 
 199:ringbuffer.c  ****         case 4:
 200:ringbuffer.c  ****           if (*((uint32_t*)compare_element) == *((uint32_t *)(&buffer->p_buffer_data[(buffer->read_
 201:ringbuffer.c  ****           {
 202:ringbuffer.c  ****             count++;
 203:ringbuffer.c  ****           }
 204:ringbuffer.c  ****         break;
 205:ringbuffer.c  **** 
 206:ringbuffer.c  ****         default:
 207:ringbuffer.c  ****         break;
 208:ringbuffer.c  ****       }
 209:ringbuffer.c  ****       
 210:ringbuffer.c  ****     } while ((++read_offset & (buffer->size - 1)) != buffer->write_pos);
 339               		.loc 1 210 0
 340 010a 2381      		ldd r18,Z+3
 341 010c 30E0      		ldi r19,0
 342 010e 2150      		subi r18,1
 343 0110 3109      		sbc r19,__zero_reg__
 344 0112 4281      		ldd r20,Z+2
 345 0114 50E0      		ldi r21,0
 170:ringbuffer.c  **** 
 346               		.loc 1 170 0
 347 0116 90E0      		ldi r25,0
 169:ringbuffer.c  ****   uint8_t read_offset = 0;
 348               		.loc 1 169 0
 349 0118 80E0      		ldi r24,0
 350               	.LVL23:
 351               	.L32:
 183:ringbuffer.c  ****       {
 352               		.loc 1 183 0
 353 011a 6230      		cpi r22,lo8(2)
 354 011c 01F0      		breq .L29
 355 011e 6430      		cpi r22,lo8(4)
 356 0120 01F0      		breq .L30
 357 0122 6130      		cpi r22,lo8(1)
 358 0124 01F4      		brne .L28
 186:ringbuffer.c  ****           {
 359               		.loc 1 186 0
 360 0126 7181      		ldd r23,Z+1
 361 0128 A681      		ldd r26,Z+6
 362 012a B781      		ldd r27,Z+7
 363 012c A70F      		add r26,r23
 364 012e B11D      		adc r27,__zero_reg__
 365 0130 A90F      		add r26,r25
 366 0132 B11D      		adc r27,__zero_reg__
 367 0134 F880      		ld r15,Y
 368 0136 7C91      		ld r23,X
 369 0138 F712      		cpse r15,r23
 370 013a 00C0      		rjmp .L28
 371 013c 00C0      		rjmp .L35
 372               	.L29:
 193:ringbuffer.c  ****           {
 373               		.loc 1 193 0
 374 013e 7181      		ldd r23,Z+1
 375 0140 A92F      		mov r26,r25
 376 0142 B0E0      		ldi r27,0
 377 0144 A70F      		add r26,r23
 378 0146 B11D      		adc r27,__zero_reg__
 379 0148 AA0F      		lsl r26
 380 014a BB1F      		rol r27
 381 014c E680      		ldd r14,Z+6
 382 014e F780      		ldd r15,Z+7
 383 0150 AE0D      		add r26,r14
 384 0152 BF1D      		adc r27,r15
 385 0154 E880      		ld r14,Y
 386 0156 F980      		ldd r15,Y+1
 387 0158 0D90      		ld __tmp_reg__,X+
 388 015a BC91      		ld r27,X
 389 015c A02D      		mov r26,__tmp_reg__
 390 015e EA16      		cp r14,r26
 391 0160 FB06      		cpc r15,r27
 392 0162 01F4      		brne .L28
 393 0164 00C0      		rjmp .L35
 394               	.L30:
 200:ringbuffer.c  ****           {
 395               		.loc 1 200 0
 396 0166 7181      		ldd r23,Z+1
 397 0168 A92F      		mov r26,r25
 398 016a B0E0      		ldi r27,0
 399 016c A70F      		add r26,r23
 400 016e B11D      		adc r27,__zero_reg__
 401 0170 AA0F      		lsl r26
 402 0172 BB1F      		rol r27
 403 0174 AA0F      		lsl r26
 404 0176 BB1F      		rol r27
 405 0178 E680      		ldd r14,Z+6
 406 017a F780      		ldd r15,Z+7
 407 017c AE0D      		add r26,r14
 408 017e BF1D      		adc r27,r15
 409 0180 8880      		ld r8,Y
 410 0182 9980      		ldd r9,Y+1
 411 0184 AA80      		ldd r10,Y+2
 412 0186 BB80      		ldd r11,Y+3
 413 0188 CD90      		ld r12,X+
 414 018a DD90      		ld r13,X+
 415 018c ED90      		ld r14,X+
 416 018e FC90      		ld r15,X
 417 0190 8C14      		cp r8,r12
 418 0192 9D04      		cpc r9,r13
 419 0194 AE04      		cpc r10,r14
 420 0196 BF04      		cpc r11,r15
 421 0198 01F4      		brne .L28
 422               	.L35:
 202:ringbuffer.c  ****           }
 423               		.loc 1 202 0
 424 019a 8F5F      		subi r24,lo8(-(1))
 425               	.LVL24:
 426               	.L28:
 427               		.loc 1 210 0
 428 019c 9F5F      		subi r25,lo8(-(1))
 429               	.LVL25:
 430 019e A92F      		mov r26,r25
 431 01a0 B0E0      		ldi r27,0
 432 01a2 A223      		and r26,r18
 433 01a4 B323      		and r27,r19
 434 01a6 A417      		cp r26,r20
 435 01a8 B507      		cpc r27,r21
 436 01aa 01F0      		breq .+2
 437 01ac 00C0      		rjmp .L32
 211:ringbuffer.c  **** 
 212:ringbuffer.c  ****     buffer->busy = 0;
 438               		.loc 1 212 0
 439 01ae 1582      		std Z+5,__zero_reg__
 213:ringbuffer.c  ****   }
 214:ringbuffer.c  ****   
 215:ringbuffer.c  ****   return count;
 440               		.loc 1 215 0
 441 01b0 00C0      		rjmp .L27
 442               	.LVL26:
 443               	.L33:
 175:ringbuffer.c  ****   }
 444               		.loc 1 175 0
 445 01b2 80E0      		ldi r24,0
 446               	.LVL27:
 447               	.L27:
 448               	/* epilogue start */
 216:ringbuffer.c  **** }
 449               		.loc 1 216 0
 450 01b4 DF91      		pop r29
 451 01b6 CF91      		pop r28
 452               	.LVL28:
 453 01b8 FF90      		pop r15
 454 01ba EF90      		pop r14
 455 01bc DF90      		pop r13
 456 01be CF90      		pop r12
 457 01c0 BF90      		pop r11
 458 01c2 AF90      		pop r10
 459 01c4 9F90      		pop r9
 460 01c6 8F90      		pop r8
 461 01c8 0895      		ret
 462               		.cfi_endproc
 463               	.LFE5:
 465               	.Letext0:
 466               		.file 2 "c:\\winavr-20100110\\avr\\include\\stdint.h"
 467               		.file 3 "ringbuffer.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ringbuffer.c
C:\Users\mcmai\AppData\Local\Temp\ccyWbOQb.s:2      *ABS*:0000003e __SP_H__
C:\Users\mcmai\AppData\Local\Temp\ccyWbOQb.s:3      *ABS*:0000003d __SP_L__
C:\Users\mcmai\AppData\Local\Temp\ccyWbOQb.s:4      *ABS*:0000003f __SREG__
C:\Users\mcmai\AppData\Local\Temp\ccyWbOQb.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\mcmai\AppData\Local\Temp\ccyWbOQb.s:6      *ABS*:00000001 __zero_reg__
C:\Users\mcmai\AppData\Local\Temp\ccyWbOQb.s:12     .text:00000000 ringbuffer__init
C:\Users\mcmai\AppData\Local\Temp\ccyWbOQb.s:47     .text:00000016 ringbuffer__push
C:\Users\mcmai\AppData\Local\Temp\ccyWbOQb.s:133    .text:0000006e ringbuffer__pop
C:\Users\mcmai\AppData\Local\Temp\ccyWbOQb.s:225    .text:000000ca ringbuffer__flush
C:\Users\mcmai\AppData\Local\Temp\ccyWbOQb.s:256    .text:000000de ringbuffer__get_state
C:\Users\mcmai\AppData\Local\Temp\ccyWbOQb.s:275    .text:000000e4 ringbuffer__contains

UNDEFINED SYMBOLS
memcpy
